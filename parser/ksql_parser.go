// Code generated from KSql.g4 by ANTLR 4.12.0. DO NOT EDIT.

package parser // KSql

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type KSqlParser struct {
	*antlr.BaseParser
}

var ksqlParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func ksqlParserInit() {
	staticData := &ksqlParserStaticData
	staticData.literalNames = []string{
		"", "';'", "','", "'('", "')'", "'.'", "'['", "']'", "'STRING'", "'EMIT'",
		"'CHANGES'", "'FINAL'", "'SELECT'", "'FROM'", "'AS'", "'ALL'", "'DISTINCT'",
		"'WHERE'", "'WITHIN'", "'WINDOW'", "'GROUP'", "'BY'", "'HAVING'", "'LIMIT'",
		"'AT'", "'OR'", "'AND'", "'IN'", "'NOT'", "'EXISTS'", "'BETWEEN'", "'LIKE'",
		"'ESCAPE'", "'IS'", "'NULL'", "'TRUE'", "'FALSE'", "'INTEGER'", "'DATE'",
		"'TIME'", "'TIMESTAMP'", "'INTERVAL'", "'YEAR'", "'MONTH'", "'DAY'",
		"'HOUR'", "'MINUTE'", "'SECOND'", "'MILLISECOND'", "'YEARS'", "'MONTHS'",
		"'DAYS'", "'HOURS'", "'MINUTES'", "'SECONDS'", "'MILLISECONDS'", "'ZONE'",
		"'TUMBLING'", "'HOPPING'", "'SIZE'", "'ADVANCE'", "'RETENTION'", "'GRACE'",
		"'PERIOD'", "'CASE'", "'WHEN'", "'THEN'", "'ELSE'", "'END'", "'JOIN'",
		"'FULL'", "'OUTER'", "'INNER'", "'LEFT'", "'RIGHT'", "'ON'", "'PARTITION'",
		"'STRUCT'", "'WITH'", "'VALUES'", "'CREATE'", "'TABLE'", "'TOPIC'",
		"'STREAM'", "'STREAMS'", "'INSERT'", "'DELETE'", "'INTO'", "'DESCRIBE'",
		"'EXTENDED'", "'PRINT'", "'EXPLAIN'", "'ANALYZE'", "'TYPE'", "'TYPES'",
		"'CAST'", "'SHOW'", "'LIST'", "'TABLES'", "'TOPICS'", "'QUERY'", "'QUERIES'",
		"'TERMINATE'", "'LOAD'", "'COLUMNS'", "'COLUMN'", "'PARTITIONS'", "'FUNCTIONS'",
		"'FUNCTION'", "'DROP'", "'TO'", "'RENAME'", "'ARRAY'", "'MAP'", "'SET'",
		"'DEFINE'", "'UNDEFINE'", "'RESET'", "'SESSION'", "'SAMPLE'", "'EXPORT'",
		"'CATALOG'", "'PROPERTIES'", "'BEGINNING'", "'UNSET'", "'RUN'", "'SCRIPT'",
		"'DECIMAL'", "'KEY'", "'CONNECTOR'", "'CONNECTORS'", "'SINK'", "'SOURCE'",
		"'NAMESPACE'", "'MATERIALIZED'", "'VIEW'", "'PRIMARY'", "'REPLACE'",
		"'ASSERT'", "'ADD'", "'ALTER'", "'VARIABLES'", "'PLUGINS'", "'HEADERS'",
		"'HEADER'", "'IF'", "'='", "", "'<'", "'<='", "'>'", "'>='", "'+'",
		"'-'", "'*'", "'/'", "'%'", "'||'", "':='", "'->'", "'=>'",
	}
	staticData.symbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "EMIT", "CHANGES", "FINAL", "SELECT",
		"FROM", "AS", "ALL", "DISTINCT", "WHERE", "WITHIN", "WINDOW", "GROUP",
		"BY", "HAVING", "LIMIT", "AT", "OR", "AND", "IN", "NOT", "EXISTS", "BETWEEN",
		"LIKE", "ESCAPE", "IS", "NULL", "TRUE", "FALSE", "INTEGER", "DATE",
		"TIME", "TIMESTAMP", "INTERVAL", "YEAR", "MONTH", "DAY", "HOUR", "MINUTE",
		"SECOND", "MILLISECOND", "YEARS", "MONTHS", "DAYS", "HOURS", "MINUTES",
		"SECONDS", "MILLISECONDS", "ZONE", "TUMBLING", "HOPPING", "SIZE", "ADVANCE",
		"RETENTION", "GRACE", "PERIOD", "CASE", "WHEN", "THEN", "ELSE", "END",
		"JOIN", "FULL", "OUTER", "INNER", "LEFT", "RIGHT", "ON", "PARTITION",
		"STRUCT", "WITH", "VALUES", "CREATE", "TABLE", "TOPIC", "STREAM", "STREAMS",
		"INSERT", "DELETE", "INTO", "DESCRIBE", "EXTENDED", "PRINT", "EXPLAIN",
		"ANALYZE", "TYPE", "TYPES", "CAST", "SHOW", "LIST", "TABLES", "TOPICS",
		"QUERY", "QUERIES", "TERMINATE", "LOAD", "COLUMNS", "COLUMN", "PARTITIONS",
		"FUNCTIONS", "FUNCTION", "DROP", "TO", "RENAME", "ARRAY", "MAP", "SET",
		"DEFINE", "UNDEFINE", "RESET", "SESSION", "SAMPLE", "EXPORT", "CATALOG",
		"PROPERTIES", "BEGINNING", "UNSET", "RUN", "SCRIPT", "DECIMAL", "KEY",
		"CONNECTOR", "CONNECTORS", "SINK", "SOURCE", "NAMESPACE", "MATERIALIZED",
		"VIEW", "PRIMARY", "REPLACE", "ASSERT", "ADD", "ALTER", "VARIABLES",
		"PLUGINS", "HEADERS", "HEADER", "IF", "EQ", "NEQ", "LT", "LTE", "GT",
		"GTE", "PLUS", "MINUS", "ASTERISK", "SLASH", "PERCENT", "CONCAT", "ASSIGN",
		"STRUCT_FIELD_REF", "LAMBDA_EXPRESSION", "STRING", "INTEGER_VALUE",
		"DECIMAL_VALUE", "FLOATING_POINT_VALUE", "IDENTIFIER", "DIGIT_IDENTIFIER",
		"QUOTED_IDENTIFIER", "BACKQUOTED_IDENTIFIER", "VARIABLE", "SIMPLE_COMMENT",
		"DIRECTIVE_COMMENT", "BRACKETED_COMMENT", "WS", "UNRECOGNIZED", "DELIMITER",
	}
	staticData.ruleNames = []string{
		"statements", "testStatement", "singleStatement", "singleExpression",
		"statement", "assertStatement", "runScript", "query", "resultMaterialization",
		"alterOption", "tableElements", "tableElement", "columnConstraints",
		"tableProperties", "tableProperty", "printClause", "intervalClause",
		"limitClause", "retentionClause", "gracePeriodClause", "windowExpression",
		"tumblingWindowExpression", "hoppingWindowExpression", "sessionWindowExpression",
		"windowUnit", "groupBy", "partitionBy", "values", "selectItem", "relation",
		"joinedSource", "joinType", "joinWindow", "withinExpression", "joinWindowSize",
		"joinCriteria", "aliasedRelation", "columns", "relationPrimary", "expression",
		"booleanExpression", "predicated", "predicate", "valueExpression", "primaryExpression",
		"functionArgument", "timeZoneSpecifier", "comparisonOperator", "booleanValue",
		"sqltype", "typeParameter", "baseType", "whenClause", "identifier",
		"lambdaFunction", "variableName", "variableValue", "sourceName", "number",
		"literal", "nonReserved",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 175, 1139, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 1, 0, 5, 0, 124, 8, 0, 10,
		0, 12, 0, 127, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 3, 1, 138, 8, 1, 1, 1, 3, 1, 141, 8, 1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3,
		1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 154, 8, 4, 1, 4, 1, 4, 3, 4,
		158, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 163, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 168,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 174, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 187, 8, 4, 1, 4, 1, 4,
		1, 4, 3, 4, 192, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 3, 4, 203, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 209, 8, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 231, 8, 4, 1, 4, 3, 4, 234,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 240, 8, 4, 1, 4, 1, 4, 3, 4, 244, 8,
		4, 1, 4, 1, 4, 3, 4, 248, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 253, 8, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 3, 4, 259, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 264, 8, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 272, 8, 4, 1, 4, 3, 4, 275, 8, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 281, 8, 4, 1, 4, 1, 4, 3, 4, 285, 8, 4, 1,
		4, 1, 4, 3, 4, 289, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 294, 8, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 3, 4, 300, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 305, 8, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 316, 8, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 327, 8, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 335, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 3, 4, 344, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 349, 8, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 3, 4, 355, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 360, 8, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 3, 4, 366, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 372,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 379, 8, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 389, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 5, 4, 398, 8, 4, 10, 4, 12, 4, 401, 9, 4, 3, 4, 403,
		8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 409, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 419, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 428, 8, 5, 1, 5, 1, 5, 3, 5, 432, 8, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 3, 5, 438, 8, 5, 1, 5, 1, 5, 3, 5, 442, 8, 5, 3, 5, 444, 8, 5,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 5, 7, 454, 8, 7, 10, 7,
		12, 7, 457, 9, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 463, 8, 7, 1, 7, 1, 7,
		3, 7, 467, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 472, 8, 7, 1, 7, 1, 7, 1, 7, 3,
		7, 477, 8, 7, 1, 7, 1, 7, 3, 7, 481, 8, 7, 1, 7, 1, 7, 3, 7, 485, 8, 7,
		1, 7, 3, 7, 488, 8, 7, 1, 8, 1, 8, 1, 9, 1, 9, 3, 9, 494, 8, 9, 1, 9, 1,
		9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 503, 8, 10, 10, 10, 12, 10,
		506, 9, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 513, 8, 11, 1, 12,
		3, 12, 516, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 524,
		8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 530, 8, 13, 10, 13, 12, 13, 533,
		9, 13, 1, 13, 1, 13, 1, 14, 1, 14, 3, 14, 539, 8, 14, 1, 14, 1, 14, 1,
		14, 1, 15, 1, 15, 3, 15, 546, 8, 15, 1, 15, 3, 15, 549, 8, 15, 1, 15, 3,
		15, 552, 8, 15, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 3, 20, 570, 8,
		20, 1, 20, 1, 20, 1, 20, 3, 20, 575, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 1, 21, 3, 21, 584, 8, 21, 1, 21, 1, 21, 3, 21, 588, 8, 21,
		1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 3, 22, 604, 8, 22, 1, 22, 1, 22, 3, 22, 608, 8,
		22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 618,
		8, 23, 1, 23, 1, 23, 3, 23, 622, 8, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1,
		25, 1, 25, 1, 25, 5, 25, 631, 8, 25, 10, 25, 12, 25, 634, 9, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 5, 25, 640, 8, 25, 10, 25, 12, 25, 643, 9, 25, 3,
		25, 645, 8, 25, 1, 25, 3, 25, 648, 8, 25, 1, 26, 1, 26, 1, 26, 5, 26, 653,
		8, 26, 10, 26, 12, 26, 656, 9, 26, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26, 662,
		8, 26, 10, 26, 12, 26, 665, 9, 26, 3, 26, 667, 8, 26, 1, 26, 3, 26, 670,
		8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 5, 27, 676, 8, 27, 10, 27, 12, 27, 679,
		9, 27, 3, 27, 681, 8, 27, 1, 27, 1, 27, 1, 28, 1, 28, 3, 28, 687, 8, 28,
		1, 28, 3, 28, 690, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 697,
		8, 28, 1, 29, 1, 29, 4, 29, 701, 8, 29, 11, 29, 12, 29, 702, 1, 29, 3,
		29, 706, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 712, 8, 30, 1, 30, 1,
		30, 1, 31, 3, 31, 717, 8, 31, 1, 31, 1, 31, 3, 31, 721, 8, 31, 1, 31, 1,
		31, 3, 31, 725, 8, 31, 3, 31, 727, 8, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 738, 8, 33, 1, 33, 1, 33, 3, 33,
		742, 8, 33, 3, 33, 744, 8, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35,
		1, 36, 1, 36, 3, 36, 754, 8, 36, 1, 36, 3, 36, 757, 8, 36, 1, 37, 1, 37,
		1, 37, 1, 37, 5, 37, 763, 8, 37, 10, 37, 12, 37, 766, 9, 37, 1, 37, 1,
		37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 778,
		8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 786, 8, 40, 10,
		40, 12, 40, 789, 9, 40, 1, 41, 1, 41, 3, 41, 793, 8, 41, 1, 42, 1, 42,
		1, 42, 1, 42, 3, 42, 799, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 3, 42, 807, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 814, 8,
		42, 10, 42, 12, 42, 817, 9, 42, 1, 42, 1, 42, 1, 42, 3, 42, 822, 8, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 828, 8, 42, 1, 42, 1, 42, 3, 42, 832,
		8, 42, 1, 42, 1, 42, 1, 42, 3, 42, 837, 8, 42, 1, 42, 1, 42, 1, 42, 3,
		42, 842, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 848, 8, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		5, 43, 862, 8, 43, 10, 43, 12, 43, 865, 9, 43, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 1, 44, 1, 44, 1, 44, 4, 44, 875, 8, 44, 11, 44, 12, 44, 876,
		1, 44, 1, 44, 3, 44, 881, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 4, 44, 887,
		8, 44, 11, 44, 12, 44, 888, 1, 44, 1, 44, 3, 44, 893, 8, 44, 1, 44, 1,
		44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
		1, 44, 1, 44, 5, 44, 909, 8, 44, 10, 44, 12, 44, 912, 9, 44, 3, 44, 914,
		8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 5, 44, 927, 8, 44, 10, 44, 12, 44, 930, 9, 44, 3, 44, 932, 8,
		44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
		1, 44, 5, 44, 945, 8, 44, 10, 44, 12, 44, 948, 9, 44, 3, 44, 950, 8, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 5, 44, 963, 8, 44, 10, 44, 12, 44, 966, 9, 44, 1, 44, 1, 44, 5, 44,
		970, 8, 44, 10, 44, 12, 44, 973, 9, 44, 3, 44, 975, 8, 44, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 988,
		8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 998,
		8, 44, 10, 44, 12, 44, 1001, 9, 44, 1, 45, 1, 45, 3, 45, 1005, 8, 45, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 1036, 8, 49,
		10, 49, 12, 49, 1039, 9, 49, 3, 49, 1041, 8, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49,
		1056, 8, 49, 10, 49, 12, 49, 1059, 9, 49, 1, 49, 1, 49, 3, 49, 1063, 8,
		49, 3, 49, 1065, 8, 49, 1, 49, 1, 49, 5, 49, 1069, 8, 49, 10, 49, 12, 49,
		1072, 9, 49, 1, 50, 1, 50, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1089, 8, 53, 1, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 1099, 8, 54, 10,
		54, 12, 54, 1102, 9, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1108, 8, 54,
		1, 55, 1, 55, 1, 56, 1, 56, 1, 57, 1, 57, 1, 58, 3, 58, 1117, 8, 58, 1,
		58, 1, 58, 3, 58, 1121, 8, 58, 1, 58, 1, 58, 3, 58, 1125, 8, 58, 1, 58,
		3, 58, 1128, 8, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1135, 8,
		59, 1, 60, 1, 60, 1, 60, 0, 4, 80, 86, 88, 98, 61, 0, 2, 4, 6, 8, 10, 12,
		14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
		50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
		86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
		118, 120, 0, 12, 1, 0, 96, 97, 1, 0, 131, 132, 2, 0, 81, 81, 83, 83, 1,
		0, 10, 11, 2, 0, 41, 41, 119, 119, 2, 0, 44, 48, 51, 55, 1, 0, 152, 153,
		1, 0, 154, 156, 1, 0, 146, 151, 1, 0, 35, 36, 2, 0, 8, 8, 162, 162, 15,
		0, 8, 11, 32, 32, 37, 47, 56, 56, 76, 77, 91, 94, 96, 96, 98, 98, 104,
		108, 112, 114, 117, 118, 128, 128, 131, 132, 136, 140, 145, 145, 1292,
		0, 125, 1, 0, 0, 0, 2, 137, 1, 0, 0, 0, 4, 142, 1, 0, 0, 0, 6, 145, 1,
		0, 0, 0, 8, 402, 1, 0, 0, 0, 10, 443, 1, 0, 0, 0, 12, 445, 1, 0, 0, 0,
		14, 449, 1, 0, 0, 0, 16, 489, 1, 0, 0, 0, 18, 491, 1, 0, 0, 0, 20, 498,
		1, 0, 0, 0, 22, 509, 1, 0, 0, 0, 24, 523, 1, 0, 0, 0, 26, 525, 1, 0, 0,
		0, 28, 538, 1, 0, 0, 0, 30, 545, 1, 0, 0, 0, 32, 553, 1, 0, 0, 0, 34, 556,
		1, 0, 0, 0, 36, 559, 1, 0, 0, 0, 38, 563, 1, 0, 0, 0, 40, 569, 1, 0, 0,
		0, 42, 576, 1, 0, 0, 0, 44, 591, 1, 0, 0, 0, 46, 611, 1, 0, 0, 0, 48, 625,
		1, 0, 0, 0, 50, 647, 1, 0, 0, 0, 52, 669, 1, 0, 0, 0, 54, 671, 1, 0, 0,
		0, 56, 696, 1, 0, 0, 0, 58, 705, 1, 0, 0, 0, 60, 707, 1, 0, 0, 0, 62, 726,
		1, 0, 0, 0, 64, 728, 1, 0, 0, 0, 66, 743, 1, 0, 0, 0, 68, 745, 1, 0, 0,
		0, 70, 748, 1, 0, 0, 0, 72, 751, 1, 0, 0, 0, 74, 758, 1, 0, 0, 0, 76, 769,
		1, 0, 0, 0, 78, 771, 1, 0, 0, 0, 80, 777, 1, 0, 0, 0, 82, 790, 1, 0, 0,
		0, 84, 841, 1, 0, 0, 0, 86, 847, 1, 0, 0, 0, 88, 987, 1, 0, 0, 0, 90, 1004,
		1, 0, 0, 0, 92, 1006, 1, 0, 0, 0, 94, 1010, 1, 0, 0, 0, 96, 1012, 1, 0,
		0, 0, 98, 1064, 1, 0, 0, 0, 100, 1073, 1, 0, 0, 0, 102, 1075, 1, 0, 0,
		0, 104, 1077, 1, 0, 0, 0, 106, 1088, 1, 0, 0, 0, 108, 1107, 1, 0, 0, 0,
		110, 1109, 1, 0, 0, 0, 112, 1111, 1, 0, 0, 0, 114, 1113, 1, 0, 0, 0, 116,
		1127, 1, 0, 0, 0, 118, 1134, 1, 0, 0, 0, 120, 1136, 1, 0, 0, 0, 122, 124,
		3, 4, 2, 0, 123, 122, 1, 0, 0, 0, 124, 127, 1, 0, 0, 0, 125, 123, 1, 0,
		0, 0, 125, 126, 1, 0, 0, 0, 126, 128, 1, 0, 0, 0, 127, 125, 1, 0, 0, 0,
		128, 129, 5, 0, 0, 1, 129, 1, 1, 0, 0, 0, 130, 138, 3, 4, 2, 0, 131, 132,
		3, 10, 5, 0, 132, 133, 5, 1, 0, 0, 133, 138, 1, 0, 0, 0, 134, 135, 3, 12,
		6, 0, 135, 136, 5, 1, 0, 0, 136, 138, 1, 0, 0, 0, 137, 130, 1, 0, 0, 0,
		137, 131, 1, 0, 0, 0, 137, 134, 1, 0, 0, 0, 138, 140, 1, 0, 0, 0, 139,
		141, 5, 0, 0, 1, 140, 139, 1, 0, 0, 0, 140, 141, 1, 0, 0, 0, 141, 3, 1,
		0, 0, 0, 142, 143, 3, 8, 4, 0, 143, 144, 5, 1, 0, 0, 144, 5, 1, 0, 0, 0,
		145, 146, 3, 78, 39, 0, 146, 147, 5, 0, 0, 1, 147, 7, 1, 0, 0, 0, 148,
		403, 3, 14, 7, 0, 149, 150, 7, 0, 0, 0, 150, 403, 5, 122, 0, 0, 151, 153,
		7, 0, 0, 0, 152, 154, 5, 15, 0, 0, 153, 152, 1, 0, 0, 0, 153, 154, 1, 0,
		0, 0, 154, 155, 1, 0, 0, 0, 155, 157, 5, 99, 0, 0, 156, 158, 5, 89, 0,
		0, 157, 156, 1, 0, 0, 0, 157, 158, 1, 0, 0, 0, 158, 403, 1, 0, 0, 0, 159,
		160, 7, 0, 0, 0, 160, 162, 5, 84, 0, 0, 161, 163, 5, 89, 0, 0, 162, 161,
		1, 0, 0, 0, 162, 163, 1, 0, 0, 0, 163, 403, 1, 0, 0, 0, 164, 165, 7, 0,
		0, 0, 165, 167, 5, 98, 0, 0, 166, 168, 5, 89, 0, 0, 167, 166, 1, 0, 0,
		0, 167, 168, 1, 0, 0, 0, 168, 403, 1, 0, 0, 0, 169, 170, 7, 0, 0, 0, 170,
		403, 5, 107, 0, 0, 171, 173, 7, 0, 0, 0, 172, 174, 7, 1, 0, 0, 173, 172,
		1, 0, 0, 0, 173, 174, 1, 0, 0, 0, 174, 175, 1, 0, 0, 0, 175, 403, 5, 130,
		0, 0, 176, 177, 7, 0, 0, 0, 177, 178, 5, 129, 0, 0, 178, 403, 5, 142, 0,
		0, 179, 180, 7, 0, 0, 0, 180, 403, 5, 94, 0, 0, 181, 182, 7, 0, 0, 0, 182,
		403, 5, 141, 0, 0, 183, 184, 5, 88, 0, 0, 184, 186, 3, 114, 57, 0, 185,
		187, 5, 89, 0, 0, 186, 185, 1, 0, 0, 0, 186, 187, 1, 0, 0, 0, 187, 403,
		1, 0, 0, 0, 188, 189, 5, 88, 0, 0, 189, 191, 5, 84, 0, 0, 190, 192, 5,
		89, 0, 0, 191, 190, 1, 0, 0, 0, 191, 192, 1, 0, 0, 0, 192, 403, 1, 0, 0,
		0, 193, 194, 5, 88, 0, 0, 194, 195, 5, 108, 0, 0, 195, 403, 3, 106, 53,
		0, 196, 197, 5, 88, 0, 0, 197, 198, 5, 129, 0, 0, 198, 403, 3, 106, 53,
		0, 199, 202, 5, 90, 0, 0, 200, 203, 3, 106, 53, 0, 201, 203, 5, 161, 0,
		0, 202, 200, 1, 0, 0, 0, 202, 201, 1, 0, 0, 0, 203, 204, 1, 0, 0, 0, 204,
		403, 3, 30, 15, 0, 205, 206, 7, 0, 0, 0, 206, 208, 5, 101, 0, 0, 207, 209,
		5, 89, 0, 0, 208, 207, 1, 0, 0, 0, 208, 209, 1, 0, 0, 0, 209, 403, 1, 0,
		0, 0, 210, 211, 5, 102, 0, 0, 211, 403, 3, 106, 53, 0, 212, 213, 5, 102,
		0, 0, 213, 403, 5, 15, 0, 0, 214, 215, 5, 114, 0, 0, 215, 216, 5, 161,
		0, 0, 216, 217, 5, 146, 0, 0, 217, 403, 5, 161, 0, 0, 218, 219, 5, 124,
		0, 0, 219, 403, 5, 161, 0, 0, 220, 221, 5, 115, 0, 0, 221, 222, 3, 110,
		55, 0, 222, 223, 5, 146, 0, 0, 223, 224, 3, 112, 56, 0, 224, 403, 1, 0,
		0, 0, 225, 226, 5, 116, 0, 0, 226, 403, 3, 110, 55, 0, 227, 230, 5, 80,
		0, 0, 228, 229, 5, 25, 0, 0, 229, 231, 5, 137, 0, 0, 230, 228, 1, 0, 0,
		0, 230, 231, 1, 0, 0, 0, 231, 233, 1, 0, 0, 0, 232, 234, 5, 132, 0, 0,
		233, 232, 1, 0, 0, 0, 233, 234, 1, 0, 0, 0, 234, 235, 1, 0, 0, 0, 235,
		239, 5, 83, 0, 0, 236, 237, 5, 145, 0, 0, 237, 238, 5, 28, 0, 0, 238, 240,
		5, 29, 0, 0, 239, 236, 1, 0, 0, 0, 239, 240, 1, 0, 0, 0, 240, 241, 1, 0,
		0, 0, 241, 243, 3, 114, 57, 0, 242, 244, 3, 20, 10, 0, 243, 242, 1, 0,
		0, 0, 243, 244, 1, 0, 0, 0, 244, 247, 1, 0, 0, 0, 245, 246, 5, 78, 0, 0,
		246, 248, 3, 26, 13, 0, 247, 245, 1, 0, 0, 0, 247, 248, 1, 0, 0, 0, 248,
		403, 1, 0, 0, 0, 249, 252, 5, 80, 0, 0, 250, 251, 5, 25, 0, 0, 251, 253,
		5, 137, 0, 0, 252, 250, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 254, 1,
		0, 0, 0, 254, 258, 5, 83, 0, 0, 255, 256, 5, 145, 0, 0, 256, 257, 5, 28,
		0, 0, 257, 259, 5, 29, 0, 0, 258, 255, 1, 0, 0, 0, 258, 259, 1, 0, 0, 0,
		259, 260, 1, 0, 0, 0, 260, 263, 3, 114, 57, 0, 261, 262, 5, 78, 0, 0, 262,
		264, 3, 26, 13, 0, 263, 261, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 265,
		1, 0, 0, 0, 265, 266, 5, 14, 0, 0, 266, 267, 3, 14, 7, 0, 267, 403, 1,
		0, 0, 0, 268, 271, 5, 80, 0, 0, 269, 270, 5, 25, 0, 0, 270, 272, 5, 137,
		0, 0, 271, 269, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272, 274, 1, 0, 0, 0,
		273, 275, 5, 132, 0, 0, 274, 273, 1, 0, 0, 0, 274, 275, 1, 0, 0, 0, 275,
		276, 1, 0, 0, 0, 276, 280, 5, 81, 0, 0, 277, 278, 5, 145, 0, 0, 278, 279,
		5, 28, 0, 0, 279, 281, 5, 29, 0, 0, 280, 277, 1, 0, 0, 0, 280, 281, 1,
		0, 0, 0, 281, 282, 1, 0, 0, 0, 282, 284, 3, 114, 57, 0, 283, 285, 3, 20,
		10, 0, 284, 283, 1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 288, 1, 0, 0, 0,
		286, 287, 5, 78, 0, 0, 287, 289, 3, 26, 13, 0, 288, 286, 1, 0, 0, 0, 288,
		289, 1, 0, 0, 0, 289, 403, 1, 0, 0, 0, 290, 293, 5, 80, 0, 0, 291, 292,
		5, 25, 0, 0, 292, 294, 5, 137, 0, 0, 293, 291, 1, 0, 0, 0, 293, 294, 1,
		0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 299, 5, 81, 0, 0, 296, 297, 5, 145,
		0, 0, 297, 298, 5, 28, 0, 0, 298, 300, 5, 29, 0, 0, 299, 296, 1, 0, 0,
		0, 299, 300, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 304, 3, 114, 57, 0,
		302, 303, 5, 78, 0, 0, 303, 305, 3, 26, 13, 0, 304, 302, 1, 0, 0, 0, 304,
		305, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 307, 5, 14, 0, 0, 307, 308,
		3, 14, 7, 0, 308, 403, 1, 0, 0, 0, 309, 310, 5, 80, 0, 0, 310, 311, 7,
		1, 0, 0, 311, 315, 5, 129, 0, 0, 312, 313, 5, 145, 0, 0, 313, 314, 5, 28,
		0, 0, 314, 316, 5, 29, 0, 0, 315, 312, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0,
		316, 317, 1, 0, 0, 0, 317, 318, 3, 106, 53, 0, 318, 319, 5, 78, 0, 0, 319,
		320, 3, 26, 13, 0, 320, 403, 1, 0, 0, 0, 321, 322, 5, 85, 0, 0, 322, 323,
		5, 87, 0, 0, 323, 326, 3, 114, 57, 0, 324, 325, 5, 78, 0, 0, 325, 327,
		3, 26, 13, 0, 326, 324, 1, 0, 0, 0, 326, 327, 1, 0, 0, 0, 327, 328, 1,
		0, 0, 0, 328, 329, 3, 14, 7, 0, 329, 403, 1, 0, 0, 0, 330, 331, 5, 85,
		0, 0, 331, 332, 5, 87, 0, 0, 332, 334, 3, 114, 57, 0, 333, 335, 3, 74,
		37, 0, 334, 333, 1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335, 336, 1, 0, 0, 0,
		336, 337, 5, 79, 0, 0, 337, 338, 3, 54, 27, 0, 338, 403, 1, 0, 0, 0, 339,
		340, 5, 109, 0, 0, 340, 343, 5, 83, 0, 0, 341, 342, 5, 145, 0, 0, 342,
		344, 5, 29, 0, 0, 343, 341, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344, 345,
		1, 0, 0, 0, 345, 348, 3, 114, 57, 0, 346, 347, 5, 86, 0, 0, 347, 349, 5,
		82, 0, 0, 348, 346, 1, 0, 0, 0, 348, 349, 1, 0, 0, 0, 349, 403, 1, 0, 0,
		0, 350, 351, 5, 109, 0, 0, 351, 354, 5, 81, 0, 0, 352, 353, 5, 145, 0,
		0, 353, 355, 5, 29, 0, 0, 354, 352, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355,
		356, 1, 0, 0, 0, 356, 359, 3, 114, 57, 0, 357, 358, 5, 86, 0, 0, 358, 360,
		5, 82, 0, 0, 359, 357, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 403, 1, 0,
		0, 0, 361, 362, 5, 109, 0, 0, 362, 365, 5, 129, 0, 0, 363, 364, 5, 145,
		0, 0, 364, 366, 5, 29, 0, 0, 365, 363, 1, 0, 0, 0, 365, 366, 1, 0, 0, 0,
		366, 367, 1, 0, 0, 0, 367, 403, 3, 106, 53, 0, 368, 371, 5, 91, 0, 0, 369,
		372, 3, 8, 4, 0, 370, 372, 3, 106, 53, 0, 371, 369, 1, 0, 0, 0, 371, 370,
		1, 0, 0, 0, 372, 403, 1, 0, 0, 0, 373, 374, 5, 80, 0, 0, 374, 378, 5, 93,
		0, 0, 375, 376, 5, 145, 0, 0, 376, 377, 5, 28, 0, 0, 377, 379, 5, 29, 0,
		0, 378, 375, 1, 0, 0, 0, 378, 379, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380,
		381, 3, 106, 53, 0, 381, 382, 5, 14, 0, 0, 382, 383, 3, 98, 49, 0, 383,
		403, 1, 0, 0, 0, 384, 385, 5, 109, 0, 0, 385, 388, 5, 93, 0, 0, 386, 387,
		5, 145, 0, 0, 387, 389, 5, 29, 0, 0, 388, 386, 1, 0, 0, 0, 388, 389, 1,
		0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 403, 3, 106, 53, 0, 391, 392, 5, 140,
		0, 0, 392, 393, 7, 2, 0, 0, 393, 394, 3, 114, 57, 0, 394, 399, 3, 18, 9,
		0, 395, 396, 5, 2, 0, 0, 396, 398, 3, 18, 9, 0, 397, 395, 1, 0, 0, 0, 398,
		401, 1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 403,
		1, 0, 0, 0, 401, 399, 1, 0, 0, 0, 402, 148, 1, 0, 0, 0, 402, 149, 1, 0,
		0, 0, 402, 151, 1, 0, 0, 0, 402, 159, 1, 0, 0, 0, 402, 164, 1, 0, 0, 0,
		402, 169, 1, 0, 0, 0, 402, 171, 1, 0, 0, 0, 402, 176, 1, 0, 0, 0, 402,
		179, 1, 0, 0, 0, 402, 181, 1, 0, 0, 0, 402, 183, 1, 0, 0, 0, 402, 188,
		1, 0, 0, 0, 402, 193, 1, 0, 0, 0, 402, 196, 1, 0, 0, 0, 402, 199, 1, 0,
		0, 0, 402, 205, 1, 0, 0, 0, 402, 210, 1, 0, 0, 0, 402, 212, 1, 0, 0, 0,
		402, 214, 1, 0, 0, 0, 402, 218, 1, 0, 0, 0, 402, 220, 1, 0, 0, 0, 402,
		225, 1, 0, 0, 0, 402, 227, 1, 0, 0, 0, 402, 249, 1, 0, 0, 0, 402, 268,
		1, 0, 0, 0, 402, 290, 1, 0, 0, 0, 402, 309, 1, 0, 0, 0, 402, 321, 1, 0,
		0, 0, 402, 330, 1, 0, 0, 0, 402, 339, 1, 0, 0, 0, 402, 350, 1, 0, 0, 0,
		402, 361, 1, 0, 0, 0, 402, 368, 1, 0, 0, 0, 402, 373, 1, 0, 0, 0, 402,
		384, 1, 0, 0, 0, 402, 391, 1, 0, 0, 0, 403, 9, 1, 0, 0, 0, 404, 405, 5,
		138, 0, 0, 405, 406, 5, 79, 0, 0, 406, 408, 3, 114, 57, 0, 407, 409, 3,
		74, 37, 0, 408, 407, 1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 410, 1, 0,
		0, 0, 410, 411, 5, 79, 0, 0, 411, 412, 3, 54, 27, 0, 412, 444, 1, 0, 0,
		0, 413, 414, 5, 138, 0, 0, 414, 415, 5, 34, 0, 0, 415, 416, 5, 79, 0, 0,
		416, 418, 3, 114, 57, 0, 417, 419, 3, 74, 37, 0, 418, 417, 1, 0, 0, 0,
		418, 419, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 421, 5, 128, 0, 0, 421,
		422, 3, 54, 27, 0, 422, 444, 1, 0, 0, 0, 423, 424, 5, 138, 0, 0, 424, 425,
		5, 83, 0, 0, 425, 427, 3, 114, 57, 0, 426, 428, 3, 20, 10, 0, 427, 426,
		1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 431, 1, 0, 0, 0, 429, 430, 5, 78,
		0, 0, 430, 432, 3, 26, 13, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0, 0,
		0, 432, 444, 1, 0, 0, 0, 433, 434, 5, 138, 0, 0, 434, 435, 5, 81, 0, 0,
		435, 437, 3, 114, 57, 0, 436, 438, 3, 20, 10, 0, 437, 436, 1, 0, 0, 0,
		437, 438, 1, 0, 0, 0, 438, 441, 1, 0, 0, 0, 439, 440, 5, 78, 0, 0, 440,
		442, 3, 26, 13, 0, 441, 439, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 444,
		1, 0, 0, 0, 443, 404, 1, 0, 0, 0, 443, 413, 1, 0, 0, 0, 443, 423, 1, 0,
		0, 0, 443, 433, 1, 0, 0, 0, 444, 11, 1, 0, 0, 0, 445, 446, 5, 125, 0, 0,
		446, 447, 5, 126, 0, 0, 447, 448, 5, 161, 0, 0, 448, 13, 1, 0, 0, 0, 449,
		450, 5, 12, 0, 0, 450, 455, 3, 56, 28, 0, 451, 452, 5, 2, 0, 0, 452, 454,
		3, 56, 28, 0, 453, 451, 1, 0, 0, 0, 454, 457, 1, 0, 0, 0, 455, 453, 1,
		0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 458, 1, 0, 0, 0, 457, 455, 1, 0, 0,
		0, 458, 459, 5, 13, 0, 0, 459, 462, 3, 58, 29, 0, 460, 461, 5, 19, 0, 0,
		461, 463, 3, 40, 20, 0, 462, 460, 1, 0, 0, 0, 462, 463, 1, 0, 0, 0, 463,
		466, 1, 0, 0, 0, 464, 465, 5, 17, 0, 0, 465, 467, 3, 80, 40, 0, 466, 464,
		1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 471, 1, 0, 0, 0, 468, 469, 5, 20,
		0, 0, 469, 470, 5, 21, 0, 0, 470, 472, 3, 50, 25, 0, 471, 468, 1, 0, 0,
		0, 471, 472, 1, 0, 0, 0, 472, 476, 1, 0, 0, 0, 473, 474, 5, 76, 0, 0, 474,
		475, 5, 21, 0, 0, 475, 477, 3, 52, 26, 0, 476, 473, 1, 0, 0, 0, 476, 477,
		1, 0, 0, 0, 477, 480, 1, 0, 0, 0, 478, 479, 5, 22, 0, 0, 479, 481, 3, 80,
		40, 0, 480, 478, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481, 484, 1, 0, 0, 0,
		482, 483, 5, 9, 0, 0, 483, 485, 3, 16, 8, 0, 484, 482, 1, 0, 0, 0, 484,
		485, 1, 0, 0, 0, 485, 487, 1, 0, 0, 0, 486, 488, 3, 34, 17, 0, 487, 486,
		1, 0, 0, 0, 487, 488, 1, 0, 0, 0, 488, 15, 1, 0, 0, 0, 489, 490, 7, 3,
		0, 0, 490, 17, 1, 0, 0, 0, 491, 493, 5, 139, 0, 0, 492, 494, 5, 105, 0,
		0, 493, 492, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495,
		496, 3, 106, 53, 0, 496, 497, 3, 98, 49, 0, 497, 19, 1, 0, 0, 0, 498, 499,
		5, 3, 0, 0, 499, 504, 3, 22, 11, 0, 500, 501, 5, 2, 0, 0, 501, 503, 3,
		22, 11, 0, 502, 500, 1, 0, 0, 0, 503, 506, 1, 0, 0, 0, 504, 502, 1, 0,
		0, 0, 504, 505, 1, 0, 0, 0, 505, 507, 1, 0, 0, 0, 506, 504, 1, 0, 0, 0,
		507, 508, 5, 4, 0, 0, 508, 21, 1, 0, 0, 0, 509, 510, 3, 106, 53, 0, 510,
		512, 3, 98, 49, 0, 511, 513, 3, 24, 12, 0, 512, 511, 1, 0, 0, 0, 512, 513,
		1, 0, 0, 0, 513, 23, 1, 0, 0, 0, 514, 516, 5, 136, 0, 0, 515, 514, 1, 0,
		0, 0, 515, 516, 1, 0, 0, 0, 516, 517, 1, 0, 0, 0, 517, 524, 5, 128, 0,
		0, 518, 524, 5, 143, 0, 0, 519, 520, 5, 144, 0, 0, 520, 521, 5, 3, 0, 0,
		521, 522, 5, 161, 0, 0, 522, 524, 5, 4, 0, 0, 523, 515, 1, 0, 0, 0, 523,
		518, 1, 0, 0, 0, 523, 519, 1, 0, 0, 0, 524, 25, 1, 0, 0, 0, 525, 526, 5,
		3, 0, 0, 526, 531, 3, 28, 14, 0, 527, 528, 5, 2, 0, 0, 528, 530, 3, 28,
		14, 0, 529, 527, 1, 0, 0, 0, 530, 533, 1, 0, 0, 0, 531, 529, 1, 0, 0, 0,
		531, 532, 1, 0, 0, 0, 532, 534, 1, 0, 0, 0, 533, 531, 1, 0, 0, 0, 534,
		535, 5, 4, 0, 0, 535, 27, 1, 0, 0, 0, 536, 539, 3, 106, 53, 0, 537, 539,
		5, 161, 0, 0, 538, 536, 1, 0, 0, 0, 538, 537, 1, 0, 0, 0, 539, 540, 1,
		0, 0, 0, 540, 541, 5, 146, 0, 0, 541, 542, 3, 118, 59, 0, 542, 29, 1, 0,
		0, 0, 543, 544, 5, 13, 0, 0, 544, 546, 5, 123, 0, 0, 545, 543, 1, 0, 0,
		0, 545, 546, 1, 0, 0, 0, 546, 548, 1, 0, 0, 0, 547, 549, 3, 32, 16, 0,
		548, 547, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 551, 1, 0, 0, 0, 550,
		552, 3, 34, 17, 0, 551, 550, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552, 31,
		1, 0, 0, 0, 553, 554, 7, 4, 0, 0, 554, 555, 3, 116, 58, 0, 555, 33, 1,
		0, 0, 0, 556, 557, 5, 23, 0, 0, 557, 558, 3, 116, 58, 0, 558, 35, 1, 0,
		0, 0, 559, 560, 5, 61, 0, 0, 560, 561, 3, 116, 58, 0, 561, 562, 3, 48,
		24, 0, 562, 37, 1, 0, 0, 0, 563, 564, 5, 62, 0, 0, 564, 565, 5, 63, 0,
		0, 565, 566, 3, 116, 58, 0, 566, 567, 3, 48, 24, 0, 567, 39, 1, 0, 0, 0,
		568, 570, 5, 165, 0, 0, 569, 568, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570,
		574, 1, 0, 0, 0, 571, 575, 3, 42, 21, 0, 572, 575, 3, 44, 22, 0, 573, 575,
		3, 46, 23, 0, 574, 571, 1, 0, 0, 0, 574, 572, 1, 0, 0, 0, 574, 573, 1,
		0, 0, 0, 575, 41, 1, 0, 0, 0, 576, 577, 5, 57, 0, 0, 577, 578, 5, 3, 0,
		0, 578, 579, 5, 59, 0, 0, 579, 580, 3, 116, 58, 0, 580, 583, 3, 48, 24,
		0, 581, 582, 5, 2, 0, 0, 582, 584, 3, 36, 18, 0, 583, 581, 1, 0, 0, 0,
		583, 584, 1, 0, 0, 0, 584, 587, 1, 0, 0, 0, 585, 586, 5, 2, 0, 0, 586,
		588, 3, 38, 19, 0, 587, 585, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 589,
		1, 0, 0, 0, 589, 590, 5, 4, 0, 0, 590, 43, 1, 0, 0, 0, 591, 592, 5, 58,
		0, 0, 592, 593, 5, 3, 0, 0, 593, 594, 5, 59, 0, 0, 594, 595, 3, 116, 58,
		0, 595, 596, 3, 48, 24, 0, 596, 597, 5, 2, 0, 0, 597, 598, 5, 60, 0, 0,
		598, 599, 5, 21, 0, 0, 599, 600, 3, 116, 58, 0, 600, 603, 3, 48, 24, 0,
		601, 602, 5, 2, 0, 0, 602, 604, 3, 36, 18, 0, 603, 601, 1, 0, 0, 0, 603,
		604, 1, 0, 0, 0, 604, 607, 1, 0, 0, 0, 605, 606, 5, 2, 0, 0, 606, 608,
		3, 38, 19, 0, 607, 605, 1, 0, 0, 0, 607, 608, 1, 0, 0, 0, 608, 609, 1,
		0, 0, 0, 609, 610, 5, 4, 0, 0, 610, 45, 1, 0, 0, 0, 611, 612, 5, 118, 0,
		0, 612, 613, 5, 3, 0, 0, 613, 614, 3, 116, 58, 0, 614, 617, 3, 48, 24,
		0, 615, 616, 5, 2, 0, 0, 616, 618, 3, 36, 18, 0, 617, 615, 1, 0, 0, 0,
		617, 618, 1, 0, 0, 0, 618, 621, 1, 0, 0, 0, 619, 620, 5, 2, 0, 0, 620,
		622, 3, 38, 19, 0, 621, 619, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0, 622, 623,
		1, 0, 0, 0, 623, 624, 5, 4, 0, 0, 624, 47, 1, 0, 0, 0, 625, 626, 7, 5,
		0, 0, 626, 49, 1, 0, 0, 0, 627, 632, 3, 86, 43, 0, 628, 629, 5, 2, 0, 0,
		629, 631, 3, 86, 43, 0, 630, 628, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632,
		630, 1, 0, 0, 0, 632, 633, 1, 0, 0, 0, 633, 648, 1, 0, 0, 0, 634, 632,
		1, 0, 0, 0, 635, 644, 5, 3, 0, 0, 636, 641, 3, 86, 43, 0, 637, 638, 5,
		2, 0, 0, 638, 640, 3, 86, 43, 0, 639, 637, 1, 0, 0, 0, 640, 643, 1, 0,
		0, 0, 641, 639, 1, 0, 0, 0, 641, 642, 1, 0, 0, 0, 642, 645, 1, 0, 0, 0,
		643, 641, 1, 0, 0, 0, 644, 636, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645,
		646, 1, 0, 0, 0, 646, 648, 5, 4, 0, 0, 647, 627, 1, 0, 0, 0, 647, 635,
		1, 0, 0, 0, 648, 51, 1, 0, 0, 0, 649, 654, 3, 86, 43, 0, 650, 651, 5, 2,
		0, 0, 651, 653, 3, 86, 43, 0, 652, 650, 1, 0, 0, 0, 653, 656, 1, 0, 0,
		0, 654, 652, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 670, 1, 0, 0, 0, 656,
		654, 1, 0, 0, 0, 657, 666, 5, 3, 0, 0, 658, 663, 3, 86, 43, 0, 659, 660,
		5, 2, 0, 0, 660, 662, 3, 86, 43, 0, 661, 659, 1, 0, 0, 0, 662, 665, 1,
		0, 0, 0, 663, 661, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 667, 1, 0, 0,
		0, 665, 663, 1, 0, 0, 0, 666, 658, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667,
		668, 1, 0, 0, 0, 668, 670, 5, 4, 0, 0, 669, 649, 1, 0, 0, 0, 669, 657,
		1, 0, 0, 0, 670, 53, 1, 0, 0, 0, 671, 680, 5, 3, 0, 0, 672, 677, 3, 86,
		43, 0, 673, 674, 5, 2, 0, 0, 674, 676, 3, 86, 43, 0, 675, 673, 1, 0, 0,
		0, 676, 679, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678,
		681, 1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 680, 672, 1, 0, 0, 0, 680, 681,
		1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 683, 5, 4, 0, 0, 683, 55, 1, 0,
		0, 0, 684, 689, 3, 78, 39, 0, 685, 687, 5, 14, 0, 0, 686, 685, 1, 0, 0,
		0, 686, 687, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 690, 3, 106, 53, 0,
		689, 686, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 697, 1, 0, 0, 0, 691,
		692, 3, 106, 53, 0, 692, 693, 5, 5, 0, 0, 693, 694, 5, 154, 0, 0, 694,
		697, 1, 0, 0, 0, 695, 697, 5, 154, 0, 0, 696, 684, 1, 0, 0, 0, 696, 691,
		1, 0, 0, 0, 696, 695, 1, 0, 0, 0, 697, 57, 1, 0, 0, 0, 698, 700, 3, 72,
		36, 0, 699, 701, 3, 60, 30, 0, 700, 699, 1, 0, 0, 0, 701, 702, 1, 0, 0,
		0, 702, 700, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 706, 1, 0, 0, 0, 704,
		706, 3, 72, 36, 0, 705, 698, 1, 0, 0, 0, 705, 704, 1, 0, 0, 0, 706, 59,
		1, 0, 0, 0, 707, 708, 3, 62, 31, 0, 708, 709, 5, 69, 0, 0, 709, 711, 3,
		72, 36, 0, 710, 712, 3, 64, 32, 0, 711, 710, 1, 0, 0, 0, 711, 712, 1, 0,
		0, 0, 712, 713, 1, 0, 0, 0, 713, 714, 3, 70, 35, 0, 714, 61, 1, 0, 0, 0,
		715, 717, 5, 72, 0, 0, 716, 715, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717,
		727, 1, 0, 0, 0, 718, 720, 5, 70, 0, 0, 719, 721, 5, 71, 0, 0, 720, 719,
		1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 727, 1, 0, 0, 0, 722, 724, 5, 73,
		0, 0, 723, 725, 5, 71, 0, 0, 724, 723, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0,
		725, 727, 1, 0, 0, 0, 726, 716, 1, 0, 0, 0, 726, 718, 1, 0, 0, 0, 726,
		722, 1, 0, 0, 0, 727, 63, 1, 0, 0, 0, 728, 729, 5, 18, 0, 0, 729, 730,
		3, 66, 33, 0, 730, 65, 1, 0, 0, 0, 731, 732, 5, 3, 0, 0, 732, 733, 3, 68,
		34, 0, 733, 734, 5, 2, 0, 0, 734, 735, 3, 68, 34, 0, 735, 737, 5, 4, 0,
		0, 736, 738, 3, 38, 19, 0, 737, 736, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0,
		738, 744, 1, 0, 0, 0, 739, 741, 3, 68, 34, 0, 740, 742, 3, 38, 19, 0, 741,
		740, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 744, 1, 0, 0, 0, 743, 731,
		1, 0, 0, 0, 743, 739, 1, 0, 0, 0, 744, 67, 1, 0, 0, 0, 745, 746, 3, 116,
		58, 0, 746, 747, 3, 48, 24, 0, 747, 69, 1, 0, 0, 0, 748, 749, 5, 75, 0,
		0, 749, 750, 3, 80, 40, 0, 750, 71, 1, 0, 0, 0, 751, 756, 3, 76, 38, 0,
		752, 754, 5, 14, 0, 0, 753, 752, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0, 754,
		755, 1, 0, 0, 0, 755, 757, 3, 114, 57, 0, 756, 753, 1, 0, 0, 0, 756, 757,
		1, 0, 0, 0, 757, 73, 1, 0, 0, 0, 758, 759, 5, 3, 0, 0, 759, 764, 3, 106,
		53, 0, 760, 761, 5, 2, 0, 0, 761, 763, 3, 106, 53, 0, 762, 760, 1, 0, 0,
		0, 763, 766, 1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765,
		767, 1, 0, 0, 0, 766, 764, 1, 0, 0, 0, 767, 768, 5, 4, 0, 0, 768, 75, 1,
		0, 0, 0, 769, 770, 3, 114, 57, 0, 770, 77, 1, 0, 0, 0, 771, 772, 3, 80,
		40, 0, 772, 79, 1, 0, 0, 0, 773, 774, 6, 40, -1, 0, 774, 778, 3, 82, 41,
		0, 775, 776, 5, 28, 0, 0, 776, 778, 3, 80, 40, 3, 777, 773, 1, 0, 0, 0,
		777, 775, 1, 0, 0, 0, 778, 787, 1, 0, 0, 0, 779, 780, 10, 2, 0, 0, 780,
		781, 5, 26, 0, 0, 781, 786, 3, 80, 40, 3, 782, 783, 10, 1, 0, 0, 783, 784,
		5, 25, 0, 0, 784, 786, 3, 80, 40, 2, 785, 779, 1, 0, 0, 0, 785, 782, 1,
		0, 0, 0, 786, 789, 1, 0, 0, 0, 787, 785, 1, 0, 0, 0, 787, 788, 1, 0, 0,
		0, 788, 81, 1, 0, 0, 0, 789, 787, 1, 0, 0, 0, 790, 792, 3, 86, 43, 0, 791,
		793, 3, 84, 42, 0, 792, 791, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 793, 83,
		1, 0, 0, 0, 794, 795, 3, 94, 47, 0, 795, 796, 3, 86, 43, 0, 796, 842, 1,
		0, 0, 0, 797, 799, 5, 28, 0, 0, 798, 797, 1, 0, 0, 0, 798, 799, 1, 0, 0,
		0, 799, 800, 1, 0, 0, 0, 800, 801, 5, 30, 0, 0, 801, 802, 3, 86, 43, 0,
		802, 803, 5, 26, 0, 0, 803, 804, 3, 86, 43, 0, 804, 842, 1, 0, 0, 0, 805,
		807, 5, 28, 0, 0, 806, 805, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807, 808,
		1, 0, 0, 0, 808, 809, 5, 27, 0, 0, 809, 810, 5, 3, 0, 0, 810, 815, 3, 78,
		39, 0, 811, 812, 5, 2, 0, 0, 812, 814, 3, 78, 39, 0, 813, 811, 1, 0, 0,
		0, 814, 817, 1, 0, 0, 0, 815, 813, 1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816,
		818, 1, 0, 0, 0, 817, 815, 1, 0, 0, 0, 818, 819, 5, 4, 0, 0, 819, 842,
		1, 0, 0, 0, 820, 822, 5, 28, 0, 0, 821, 820, 1, 0, 0, 0, 821, 822, 1, 0,
		0, 0, 822, 823, 1, 0, 0, 0, 823, 824, 5, 31, 0, 0, 824, 827, 3, 86, 43,
		0, 825, 826, 5, 32, 0, 0, 826, 828, 5, 161, 0, 0, 827, 825, 1, 0, 0, 0,
		827, 828, 1, 0, 0, 0, 828, 842, 1, 0, 0, 0, 829, 831, 5, 33, 0, 0, 830,
		832, 5, 28, 0, 0, 831, 830, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832, 833,
		1, 0, 0, 0, 833, 842, 5, 34, 0, 0, 834, 836, 5, 33, 0, 0, 835, 837, 5,
		28, 0, 0, 836, 835, 1, 0, 0, 0, 836, 837, 1, 0, 0, 0, 837, 838, 1, 0, 0,
		0, 838, 839, 5, 16, 0, 0, 839, 840, 5, 13, 0, 0, 840, 842, 3, 86, 43, 0,
		841, 794, 1, 0, 0, 0, 841, 798, 1, 0, 0, 0, 841, 806, 1, 0, 0, 0, 841,
		821, 1, 0, 0, 0, 841, 829, 1, 0, 0, 0, 841, 834, 1, 0, 0, 0, 842, 85, 1,
		0, 0, 0, 843, 844, 6, 43, -1, 0, 844, 848, 3, 88, 44, 0, 845, 846, 7, 6,
		0, 0, 846, 848, 3, 86, 43, 4, 847, 843, 1, 0, 0, 0, 847, 845, 1, 0, 0,
		0, 848, 863, 1, 0, 0, 0, 849, 850, 10, 3, 0, 0, 850, 851, 7, 7, 0, 0, 851,
		862, 3, 86, 43, 4, 852, 853, 10, 2, 0, 0, 853, 854, 7, 6, 0, 0, 854, 862,
		3, 86, 43, 3, 855, 856, 10, 1, 0, 0, 856, 857, 5, 157, 0, 0, 857, 862,
		3, 86, 43, 2, 858, 859, 10, 5, 0, 0, 859, 860, 5, 24, 0, 0, 860, 862, 3,
		92, 46, 0, 861, 849, 1, 0, 0, 0, 861, 852, 1, 0, 0, 0, 861, 855, 1, 0,
		0, 0, 861, 858, 1, 0, 0, 0, 862, 865, 1, 0, 0, 0, 863, 861, 1, 0, 0, 0,
		863, 864, 1, 0, 0, 0, 864, 87, 1, 0, 0, 0, 865, 863, 1, 0, 0, 0, 866, 867,
		6, 44, -1, 0, 867, 988, 3, 118, 59, 0, 868, 869, 3, 106, 53, 0, 869, 870,
		5, 161, 0, 0, 870, 988, 1, 0, 0, 0, 871, 872, 5, 64, 0, 0, 872, 874, 3,
		86, 43, 0, 873, 875, 3, 104, 52, 0, 874, 873, 1, 0, 0, 0, 875, 876, 1,
		0, 0, 0, 876, 874, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 880, 1, 0, 0,
		0, 878, 879, 5, 67, 0, 0, 879, 881, 3, 78, 39, 0, 880, 878, 1, 0, 0, 0,
		880, 881, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 883, 5, 68, 0, 0, 883,
		988, 1, 0, 0, 0, 884, 886, 5, 64, 0, 0, 885, 887, 3, 104, 52, 0, 886, 885,
		1, 0, 0, 0, 887, 888, 1, 0, 0, 0, 888, 886, 1, 0, 0, 0, 888, 889, 1, 0,
		0, 0, 889, 892, 1, 0, 0, 0, 890, 891, 5, 67, 0, 0, 891, 893, 3, 78, 39,
		0, 892, 890, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894,
		895, 5, 68, 0, 0, 895, 988, 1, 0, 0, 0, 896, 897, 5, 95, 0, 0, 897, 898,
		5, 3, 0, 0, 898, 899, 3, 78, 39, 0, 899, 900, 5, 14, 0, 0, 900, 901, 3,
		98, 49, 0, 901, 902, 5, 4, 0, 0, 902, 988, 1, 0, 0, 0, 903, 904, 5, 112,
		0, 0, 904, 913, 5, 6, 0, 0, 905, 910, 3, 78, 39, 0, 906, 907, 5, 2, 0,
		0, 907, 909, 3, 78, 39, 0, 908, 906, 1, 0, 0, 0, 909, 912, 1, 0, 0, 0,
		910, 908, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 914, 1, 0, 0, 0, 912,
		910, 1, 0, 0, 0, 913, 905, 1, 0, 0, 0, 913, 914, 1, 0, 0, 0, 914, 915,
		1, 0, 0, 0, 915, 988, 5, 7, 0, 0, 916, 917, 5, 113, 0, 0, 917, 931, 5,
		3, 0, 0, 918, 919, 3, 78, 39, 0, 919, 920, 5, 158, 0, 0, 920, 928, 3, 78,
		39, 0, 921, 922, 5, 2, 0, 0, 922, 923, 3, 78, 39, 0, 923, 924, 5, 158,
		0, 0, 924, 925, 3, 78, 39, 0, 925, 927, 1, 0, 0, 0, 926, 921, 1, 0, 0,
		0, 927, 930, 1, 0, 0, 0, 928, 926, 1, 0, 0, 0, 928, 929, 1, 0, 0, 0, 929,
		932, 1, 0, 0, 0, 930, 928, 1, 0, 0, 0, 931, 918, 1, 0, 0, 0, 931, 932,
		1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 988, 5, 4, 0, 0, 934, 935, 5, 77,
		0, 0, 935, 949, 5, 3, 0, 0, 936, 937, 3, 106, 53, 0, 937, 938, 5, 158,
		0, 0, 938, 946, 3, 78, 39, 0, 939, 940, 5, 2, 0, 0, 940, 941, 3, 106, 53,
		0, 941, 942, 5, 158, 0, 0, 942, 943, 3, 78, 39, 0, 943, 945, 1, 0, 0, 0,
		944, 939, 1, 0, 0, 0, 945, 948, 1, 0, 0, 0, 946, 944, 1, 0, 0, 0, 946,
		947, 1, 0, 0, 0, 947, 950, 1, 0, 0, 0, 948, 946, 1, 0, 0, 0, 949, 936,
		1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 988, 5, 4,
		0, 0, 952, 953, 3, 106, 53, 0, 953, 954, 5, 3, 0, 0, 954, 955, 5, 154,
		0, 0, 955, 956, 5, 4, 0, 0, 956, 988, 1, 0, 0, 0, 957, 958, 3, 106, 53,
		0, 958, 974, 5, 3, 0, 0, 959, 964, 3, 90, 45, 0, 960, 961, 5, 2, 0, 0,
		961, 963, 3, 90, 45, 0, 962, 960, 1, 0, 0, 0, 963, 966, 1, 0, 0, 0, 964,
		962, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0, 965, 971, 1, 0, 0, 0, 966, 964,
		1, 0, 0, 0, 967, 968, 5, 2, 0, 0, 968, 970, 3, 108, 54, 0, 969, 967, 1,
		0, 0, 0, 970, 973, 1, 0, 0, 0, 971, 969, 1, 0, 0, 0, 971, 972, 1, 0, 0,
		0, 972, 975, 1, 0, 0, 0, 973, 971, 1, 0, 0, 0, 974, 959, 1, 0, 0, 0, 974,
		975, 1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 976, 977, 5, 4, 0, 0, 977, 988,
		1, 0, 0, 0, 978, 988, 3, 106, 53, 0, 979, 980, 3, 106, 53, 0, 980, 981,
		5, 5, 0, 0, 981, 982, 3, 106, 53, 0, 982, 988, 1, 0, 0, 0, 983, 984, 5,
		3, 0, 0, 984, 985, 3, 78, 39, 0, 985, 986, 5, 4, 0, 0, 986, 988, 1, 0,
		0, 0, 987, 866, 1, 0, 0, 0, 987, 868, 1, 0, 0, 0, 987, 871, 1, 0, 0, 0,
		987, 884, 1, 0, 0, 0, 987, 896, 1, 0, 0, 0, 987, 903, 1, 0, 0, 0, 987,
		916, 1, 0, 0, 0, 987, 934, 1, 0, 0, 0, 987, 952, 1, 0, 0, 0, 987, 957,
		1, 0, 0, 0, 987, 978, 1, 0, 0, 0, 987, 979, 1, 0, 0, 0, 987, 983, 1, 0,
		0, 0, 988, 999, 1, 0, 0, 0, 989, 990, 10, 5, 0, 0, 990, 991, 5, 6, 0, 0,
		991, 992, 3, 86, 43, 0, 992, 993, 5, 7, 0, 0, 993, 998, 1, 0, 0, 0, 994,
		995, 10, 2, 0, 0, 995, 996, 5, 159, 0, 0, 996, 998, 3, 106, 53, 0, 997,
		989, 1, 0, 0, 0, 997, 994, 1, 0, 0, 0, 998, 1001, 1, 0, 0, 0, 999, 997,
		1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000, 89, 1, 0, 0, 0, 1001, 999, 1,
		0, 0, 0, 1002, 1005, 3, 78, 39, 0, 1003, 1005, 3, 48, 24, 0, 1004, 1002,
		1, 0, 0, 0, 1004, 1003, 1, 0, 0, 0, 1005, 91, 1, 0, 0, 0, 1006, 1007, 5,
		39, 0, 0, 1007, 1008, 5, 56, 0, 0, 1008, 1009, 5, 161, 0, 0, 1009, 93,
		1, 0, 0, 0, 1010, 1011, 7, 8, 0, 0, 1011, 95, 1, 0, 0, 0, 1012, 1013, 7,
		9, 0, 0, 1013, 97, 1, 0, 0, 0, 1014, 1015, 6, 49, -1, 0, 1015, 1016, 5,
		112, 0, 0, 1016, 1017, 5, 148, 0, 0, 1017, 1018, 3, 98, 49, 0, 1018, 1019,
		5, 150, 0, 0, 1019, 1065, 1, 0, 0, 0, 1020, 1021, 5, 113, 0, 0, 1021, 1022,
		5, 148, 0, 0, 1022, 1023, 3, 98, 49, 0, 1023, 1024, 5, 2, 0, 0, 1024, 1025,
		3, 98, 49, 0, 1025, 1026, 5, 150, 0, 0, 1026, 1065, 1, 0, 0, 0, 1027, 1028,
		5, 77, 0, 0, 1028, 1040, 5, 148, 0, 0, 1029, 1030, 3, 106, 53, 0, 1030,
		1037, 3, 98, 49, 0, 1031, 1032, 5, 2, 0, 0, 1032, 1033, 3, 106, 53, 0,
		1033, 1034, 3, 98, 49, 0, 1034, 1036, 1, 0, 0, 0, 1035, 1031, 1, 0, 0,
		0, 1036, 1039, 1, 0, 0, 0, 1037, 1035, 1, 0, 0, 0, 1037, 1038, 1, 0, 0,
		0, 1038, 1041, 1, 0, 0, 0, 1039, 1037, 1, 0, 0, 0, 1040, 1029, 1, 0, 0,
		0, 1040, 1041, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1065, 5, 150,
		0, 0, 1043, 1044, 5, 127, 0, 0, 1044, 1045, 5, 3, 0, 0, 1045, 1046, 3,
		116, 58, 0, 1046, 1047, 5, 2, 0, 0, 1047, 1048, 3, 116, 58, 0, 1048, 1049,
		5, 4, 0, 0, 1049, 1065, 1, 0, 0, 0, 1050, 1062, 3, 102, 51, 0, 1051, 1052,
		5, 3, 0, 0, 1052, 1057, 3, 100, 50, 0, 1053, 1054, 5, 2, 0, 0, 1054, 1056,
		3, 100, 50, 0, 1055, 1053, 1, 0, 0, 0, 1056, 1059, 1, 0, 0, 0, 1057, 1055,
		1, 0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058, 1060, 1, 0, 0, 0, 1059, 1057,
		1, 0, 0, 0, 1060, 1061, 5, 4, 0, 0, 1061, 1063, 1, 0, 0, 0, 1062, 1051,
		1, 0, 0, 0, 1062, 1063, 1, 0, 0, 0, 1063, 1065, 1, 0, 0, 0, 1064, 1014,
		1, 0, 0, 0, 1064, 1020, 1, 0, 0, 0, 1064, 1027, 1, 0, 0, 0, 1064, 1043,
		1, 0, 0, 0, 1064, 1050, 1, 0, 0, 0, 1065, 1070, 1, 0, 0, 0, 1066, 1067,
		10, 6, 0, 0, 1067, 1069, 5, 112, 0, 0, 1068, 1066, 1, 0, 0, 0, 1069, 1072,
		1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1070, 1071, 1, 0, 0, 0, 1071, 99, 1,
		0, 0, 0, 1072, 1070, 1, 0, 0, 0, 1073, 1074, 7, 10, 0, 0, 1074, 101, 1,
		0, 0, 0, 1075, 1076, 3, 106, 53, 0, 1076, 103, 1, 0, 0, 0, 1077, 1078,
		5, 65, 0, 0, 1078, 1079, 3, 78, 39, 0, 1079, 1080, 5, 66, 0, 0, 1080, 1081,
		3, 78, 39, 0, 1081, 105, 1, 0, 0, 0, 1082, 1089, 5, 169, 0, 0, 1083, 1089,
		5, 165, 0, 0, 1084, 1089, 5, 167, 0, 0, 1085, 1089, 3, 120, 60, 0, 1086,
		1089, 5, 168, 0, 0, 1087, 1089, 5, 166, 0, 0, 1088, 1082, 1, 0, 0, 0, 1088,
		1083, 1, 0, 0, 0, 1088, 1084, 1, 0, 0, 0, 1088, 1085, 1, 0, 0, 0, 1088,
		1086, 1, 0, 0, 0, 1088, 1087, 1, 0, 0, 0, 1089, 107, 1, 0, 0, 0, 1090,
		1091, 3, 106, 53, 0, 1091, 1092, 5, 160, 0, 0, 1092, 1093, 3, 78, 39, 0,
		1093, 1108, 1, 0, 0, 0, 1094, 1095, 5, 3, 0, 0, 1095, 1100, 3, 106, 53,
		0, 1096, 1097, 5, 2, 0, 0, 1097, 1099, 3, 106, 53, 0, 1098, 1096, 1, 0,
		0, 0, 1099, 1102, 1, 0, 0, 0, 1100, 1098, 1, 0, 0, 0, 1100, 1101, 1, 0,
		0, 0, 1101, 1103, 1, 0, 0, 0, 1102, 1100, 1, 0, 0, 0, 1103, 1104, 5, 4,
		0, 0, 1104, 1105, 5, 160, 0, 0, 1105, 1106, 3, 78, 39, 0, 1106, 1108, 1,
		0, 0, 0, 1107, 1090, 1, 0, 0, 0, 1107, 1094, 1, 0, 0, 0, 1108, 109, 1,
		0, 0, 0, 1109, 1110, 5, 165, 0, 0, 1110, 111, 1, 0, 0, 0, 1111, 1112, 5,
		161, 0, 0, 1112, 113, 1, 0, 0, 0, 1113, 1114, 3, 106, 53, 0, 1114, 115,
		1, 0, 0, 0, 1115, 1117, 5, 153, 0, 0, 1116, 1115, 1, 0, 0, 0, 1116, 1117,
		1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 1128, 5, 163, 0, 0, 1119, 1121,
		5, 153, 0, 0, 1120, 1119, 1, 0, 0, 0, 1120, 1121, 1, 0, 0, 0, 1121, 1122,
		1, 0, 0, 0, 1122, 1128, 5, 164, 0, 0, 1123, 1125, 5, 153, 0, 0, 1124, 1123,
		1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126, 1128,
		5, 162, 0, 0, 1127, 1116, 1, 0, 0, 0, 1127, 1120, 1, 0, 0, 0, 1127, 1124,
		1, 0, 0, 0, 1128, 117, 1, 0, 0, 0, 1129, 1135, 5, 34, 0, 0, 1130, 1135,
		3, 116, 58, 0, 1131, 1135, 3, 96, 48, 0, 1132, 1135, 5, 161, 0, 0, 1133,
		1135, 5, 169, 0, 0, 1134, 1129, 1, 0, 0, 0, 1134, 1130, 1, 0, 0, 0, 1134,
		1131, 1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1134, 1133, 1, 0, 0, 0, 1135,
		119, 1, 0, 0, 0, 1136, 1137, 7, 11, 0, 0, 1137, 121, 1, 0, 0, 0, 146, 125,
		137, 140, 153, 157, 162, 167, 173, 186, 191, 202, 208, 230, 233, 239, 243,
		247, 252, 258, 263, 271, 274, 280, 284, 288, 293, 299, 304, 315, 326, 334,
		343, 348, 354, 359, 365, 371, 378, 388, 399, 402, 408, 418, 427, 431, 437,
		441, 443, 455, 462, 466, 471, 476, 480, 484, 487, 493, 504, 512, 515, 523,
		531, 538, 545, 548, 551, 569, 574, 583, 587, 603, 607, 617, 621, 632, 641,
		644, 647, 654, 663, 666, 669, 677, 680, 686, 689, 696, 702, 705, 711, 716,
		720, 724, 726, 737, 741, 743, 753, 756, 764, 777, 785, 787, 792, 798, 806,
		815, 821, 827, 831, 836, 841, 847, 861, 863, 876, 880, 888, 892, 910, 913,
		928, 931, 946, 949, 964, 971, 974, 987, 997, 999, 1004, 1037, 1040, 1057,
		1062, 1064, 1070, 1088, 1100, 1107, 1116, 1120, 1124, 1127, 1134,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// KSqlParserInit initializes any static state used to implement KSqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewKSqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func KSqlParserInit() {
	staticData := &ksqlParserStaticData
	staticData.once.Do(ksqlParserInit)
}

// NewKSqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewKSqlParser(input antlr.TokenStream) *KSqlParser {
	KSqlParserInit()
	this := new(KSqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ksqlParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "KSql.g4"

	return this
}

// KSqlParser tokens.
const (
	KSqlParserEOF                   = antlr.TokenEOF
	KSqlParserT__0                  = 1
	KSqlParserT__1                  = 2
	KSqlParserT__2                  = 3
	KSqlParserT__3                  = 4
	KSqlParserT__4                  = 5
	KSqlParserT__5                  = 6
	KSqlParserT__6                  = 7
	KSqlParserT__7                  = 8
	KSqlParserEMIT                  = 9
	KSqlParserCHANGES               = 10
	KSqlParserFINAL                 = 11
	KSqlParserSELECT                = 12
	KSqlParserFROM                  = 13
	KSqlParserAS                    = 14
	KSqlParserALL                   = 15
	KSqlParserDISTINCT              = 16
	KSqlParserWHERE                 = 17
	KSqlParserWITHIN                = 18
	KSqlParserWINDOW                = 19
	KSqlParserGROUP                 = 20
	KSqlParserBY                    = 21
	KSqlParserHAVING                = 22
	KSqlParserLIMIT                 = 23
	KSqlParserAT                    = 24
	KSqlParserOR                    = 25
	KSqlParserAND                   = 26
	KSqlParserIN                    = 27
	KSqlParserNOT                   = 28
	KSqlParserEXISTS                = 29
	KSqlParserBETWEEN               = 30
	KSqlParserLIKE                  = 31
	KSqlParserESCAPE                = 32
	KSqlParserIS                    = 33
	KSqlParserNULL                  = 34
	KSqlParserTRUE                  = 35
	KSqlParserFALSE                 = 36
	KSqlParserINTEGER               = 37
	KSqlParserDATE                  = 38
	KSqlParserTIME                  = 39
	KSqlParserTIMESTAMP             = 40
	KSqlParserINTERVAL              = 41
	KSqlParserYEAR                  = 42
	KSqlParserMONTH                 = 43
	KSqlParserDAY                   = 44
	KSqlParserHOUR                  = 45
	KSqlParserMINUTE                = 46
	KSqlParserSECOND                = 47
	KSqlParserMILLISECOND           = 48
	KSqlParserYEARS                 = 49
	KSqlParserMONTHS                = 50
	KSqlParserDAYS                  = 51
	KSqlParserHOURS                 = 52
	KSqlParserMINUTES               = 53
	KSqlParserSECONDS               = 54
	KSqlParserMILLISECONDS          = 55
	KSqlParserZONE                  = 56
	KSqlParserTUMBLING              = 57
	KSqlParserHOPPING               = 58
	KSqlParserSIZE                  = 59
	KSqlParserADVANCE               = 60
	KSqlParserRETENTION             = 61
	KSqlParserGRACE                 = 62
	KSqlParserPERIOD                = 63
	KSqlParserCASE                  = 64
	KSqlParserWHEN                  = 65
	KSqlParserTHEN                  = 66
	KSqlParserELSE                  = 67
	KSqlParserEND                   = 68
	KSqlParserJOIN                  = 69
	KSqlParserFULL                  = 70
	KSqlParserOUTER                 = 71
	KSqlParserINNER                 = 72
	KSqlParserLEFT                  = 73
	KSqlParserRIGHT                 = 74
	KSqlParserON                    = 75
	KSqlParserPARTITION             = 76
	KSqlParserSTRUCT                = 77
	KSqlParserWITH                  = 78
	KSqlParserVALUES                = 79
	KSqlParserCREATE                = 80
	KSqlParserTABLE                 = 81
	KSqlParserTOPIC                 = 82
	KSqlParserSTREAM                = 83
	KSqlParserSTREAMS               = 84
	KSqlParserINSERT                = 85
	KSqlParserDELETE                = 86
	KSqlParserINTO                  = 87
	KSqlParserDESCRIBE              = 88
	KSqlParserEXTENDED              = 89
	KSqlParserPRINT                 = 90
	KSqlParserEXPLAIN               = 91
	KSqlParserANALYZE               = 92
	KSqlParserTYPE                  = 93
	KSqlParserTYPES                 = 94
	KSqlParserCAST                  = 95
	KSqlParserSHOW                  = 96
	KSqlParserLIST                  = 97
	KSqlParserTABLES                = 98
	KSqlParserTOPICS                = 99
	KSqlParserQUERY                 = 100
	KSqlParserQUERIES               = 101
	KSqlParserTERMINATE             = 102
	KSqlParserLOAD                  = 103
	KSqlParserCOLUMNS               = 104
	KSqlParserCOLUMN                = 105
	KSqlParserPARTITIONS            = 106
	KSqlParserFUNCTIONS             = 107
	KSqlParserFUNCTION              = 108
	KSqlParserDROP                  = 109
	KSqlParserTO                    = 110
	KSqlParserRENAME                = 111
	KSqlParserARRAY                 = 112
	KSqlParserMAP                   = 113
	KSqlParserSET                   = 114
	KSqlParserDEFINE                = 115
	KSqlParserUNDEFINE              = 116
	KSqlParserRESET                 = 117
	KSqlParserSESSION               = 118
	KSqlParserSAMPLE                = 119
	KSqlParserEXPORT                = 120
	KSqlParserCATALOG               = 121
	KSqlParserPROPERTIES            = 122
	KSqlParserBEGINNING             = 123
	KSqlParserUNSET                 = 124
	KSqlParserRUN                   = 125
	KSqlParserSCRIPT                = 126
	KSqlParserDECIMAL               = 127
	KSqlParserKEY                   = 128
	KSqlParserCONNECTOR             = 129
	KSqlParserCONNECTORS            = 130
	KSqlParserSINK                  = 131
	KSqlParserSOURCE                = 132
	KSqlParserNAMESPACE             = 133
	KSqlParserMATERIALIZED          = 134
	KSqlParserVIEW                  = 135
	KSqlParserPRIMARY               = 136
	KSqlParserREPLACE               = 137
	KSqlParserASSERT                = 138
	KSqlParserADD                   = 139
	KSqlParserALTER                 = 140
	KSqlParserVARIABLES             = 141
	KSqlParserPLUGINS               = 142
	KSqlParserHEADERS               = 143
	KSqlParserHEADER                = 144
	KSqlParserIF                    = 145
	KSqlParserEQ                    = 146
	KSqlParserNEQ                   = 147
	KSqlParserLT                    = 148
	KSqlParserLTE                   = 149
	KSqlParserGT                    = 150
	KSqlParserGTE                   = 151
	KSqlParserPLUS                  = 152
	KSqlParserMINUS                 = 153
	KSqlParserASTERISK              = 154
	KSqlParserSLASH                 = 155
	KSqlParserPERCENT               = 156
	KSqlParserCONCAT                = 157
	KSqlParserASSIGN                = 158
	KSqlParserSTRUCT_FIELD_REF      = 159
	KSqlParserLAMBDA_EXPRESSION     = 160
	KSqlParserSTRING                = 161
	KSqlParserINTEGER_VALUE         = 162
	KSqlParserDECIMAL_VALUE         = 163
	KSqlParserFLOATING_POINT_VALUE  = 164
	KSqlParserIDENTIFIER            = 165
	KSqlParserDIGIT_IDENTIFIER      = 166
	KSqlParserQUOTED_IDENTIFIER     = 167
	KSqlParserBACKQUOTED_IDENTIFIER = 168
	KSqlParserVARIABLE              = 169
	KSqlParserSIMPLE_COMMENT        = 170
	KSqlParserDIRECTIVE_COMMENT     = 171
	KSqlParserBRACKETED_COMMENT     = 172
	KSqlParserWS                    = 173
	KSqlParserUNRECOGNIZED          = 174
	KSqlParserDELIMITER             = 175
)

// KSqlParser rules.
const (
	KSqlParserRULE_statements               = 0
	KSqlParserRULE_testStatement            = 1
	KSqlParserRULE_singleStatement          = 2
	KSqlParserRULE_singleExpression         = 3
	KSqlParserRULE_statement                = 4
	KSqlParserRULE_assertStatement          = 5
	KSqlParserRULE_runScript                = 6
	KSqlParserRULE_query                    = 7
	KSqlParserRULE_resultMaterialization    = 8
	KSqlParserRULE_alterOption              = 9
	KSqlParserRULE_tableElements            = 10
	KSqlParserRULE_tableElement             = 11
	KSqlParserRULE_columnConstraints        = 12
	KSqlParserRULE_tableProperties          = 13
	KSqlParserRULE_tableProperty            = 14
	KSqlParserRULE_printClause              = 15
	KSqlParserRULE_intervalClause           = 16
	KSqlParserRULE_limitClause              = 17
	KSqlParserRULE_retentionClause          = 18
	KSqlParserRULE_gracePeriodClause        = 19
	KSqlParserRULE_windowExpression         = 20
	KSqlParserRULE_tumblingWindowExpression = 21
	KSqlParserRULE_hoppingWindowExpression  = 22
	KSqlParserRULE_sessionWindowExpression  = 23
	KSqlParserRULE_windowUnit               = 24
	KSqlParserRULE_groupBy                  = 25
	KSqlParserRULE_partitionBy              = 26
	KSqlParserRULE_values                   = 27
	KSqlParserRULE_selectItem               = 28
	KSqlParserRULE_relation                 = 29
	KSqlParserRULE_joinedSource             = 30
	KSqlParserRULE_joinType                 = 31
	KSqlParserRULE_joinWindow               = 32
	KSqlParserRULE_withinExpression         = 33
	KSqlParserRULE_joinWindowSize           = 34
	KSqlParserRULE_joinCriteria             = 35
	KSqlParserRULE_aliasedRelation          = 36
	KSqlParserRULE_columns                  = 37
	KSqlParserRULE_relationPrimary          = 38
	KSqlParserRULE_expression               = 39
	KSqlParserRULE_booleanExpression        = 40
	KSqlParserRULE_predicated               = 41
	KSqlParserRULE_predicate                = 42
	KSqlParserRULE_valueExpression          = 43
	KSqlParserRULE_primaryExpression        = 44
	KSqlParserRULE_functionArgument         = 45
	KSqlParserRULE_timeZoneSpecifier        = 46
	KSqlParserRULE_comparisonOperator       = 47
	KSqlParserRULE_booleanValue             = 48
	KSqlParserRULE_sqltype                  = 49
	KSqlParserRULE_typeParameter            = 50
	KSqlParserRULE_baseType                 = 51
	KSqlParserRULE_whenClause               = 52
	KSqlParserRULE_identifier               = 53
	KSqlParserRULE_lambdaFunction           = 54
	KSqlParserRULE_variableName             = 55
	KSqlParserRULE_variableValue            = 56
	KSqlParserRULE_sourceName               = 57
	KSqlParserRULE_number                   = 58
	KSqlParserRULE_literal                  = 59
	KSqlParserRULE_nonReserved              = 60
)

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSingleStatement() []ISingleStatementContext
	SingleStatement(i int) ISingleStatementContext

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *StatementsContext) AllSingleStatement() []ISingleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleStatementContext); ok {
			len++
		}
	}

	tst := make([]ISingleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleStatementContext); ok {
			tst[i] = t.(ISingleStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *KSqlParser) Statements() (localctx IStatementsContext) {
	this := p
	_ = this

	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KSqlParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(125)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserSELECT || ((int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&1152939217593240865) != 0) {
		{
			p.SetState(122)
			p.SingleStatement()
		}

		p.SetState(127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(128)
		p.Match(KSqlParserEOF)
	}

	return localctx
}

// ITestStatementContext is an interface to support dynamic dispatch.
type ITestStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleStatement() ISingleStatementContext
	AssertStatement() IAssertStatementContext
	RunScript() IRunScriptContext
	EOF() antlr.TerminalNode

	// IsTestStatementContext differentiates from other interfaces.
	IsTestStatementContext()
}

type TestStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestStatementContext() *TestStatementContext {
	var p = new(TestStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_testStatement
	return p
}

func (*TestStatementContext) IsTestStatementContext() {}

func NewTestStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestStatementContext {
	var p = new(TestStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_testStatement

	return p
}

func (s *TestStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TestStatementContext) SingleStatement() ISingleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *TestStatementContext) AssertStatement() IAssertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *TestStatementContext) RunScript() IRunScriptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRunScriptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRunScriptContext)
}

func (s *TestStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *TestStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTestStatement(s)
	}
}

func (s *TestStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTestStatement(s)
	}
}

func (p *KSqlParser) TestStatement() (localctx ITestStatementContext) {
	this := p
	_ = this

	localctx = NewTestStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KSqlParserRULE_testStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(137)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserSELECT, KSqlParserCREATE, KSqlParserINSERT, KSqlParserDESCRIBE, KSqlParserPRINT, KSqlParserEXPLAIN, KSqlParserSHOW, KSqlParserLIST, KSqlParserTERMINATE, KSqlParserDROP, KSqlParserSET, KSqlParserDEFINE, KSqlParserUNDEFINE, KSqlParserUNSET, KSqlParserALTER:
		{
			p.SetState(130)
			p.SingleStatement()
		}

	case KSqlParserASSERT:
		{
			p.SetState(131)
			p.AssertStatement()
		}
		{
			p.SetState(132)
			p.Match(KSqlParserT__0)
		}

	case KSqlParserRUN:
		{
			p.SetState(134)
			p.RunScript()
		}
		{
			p.SetState(135)
			p.Match(KSqlParserT__0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(140)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(139)
			p.Match(KSqlParserEOF)
		}

	}

	return localctx
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_singleStatement
	return p
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *KSqlParser) SingleStatement() (localctx ISingleStatementContext) {
	this := p
	_ = this

	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KSqlParserRULE_singleStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(142)
		p.Statement()
	}
	{
		p.SetState(143)
		p.Match(KSqlParserT__0)
	}

	return localctx
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	EOF() antlr.TerminalNode

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_singleExpression
	return p
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleExpression(s)
	}
}

func (s *SingleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleExpression(s)
	}
}

func (p *KSqlParser) SingleExpression() (localctx ISingleExpressionContext) {
	this := p
	_ = this

	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KSqlParserRULE_singleExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(145)
		p.Expression()
	}
	{
		p.SetState(146)
		p.Match(KSqlParserEOF)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ListTablesContext struct {
	*StatementContext
}

func NewListTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTablesContext {
	var p = new(ListTablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLES, 0)
}

func (s *ListTablesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTablesContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTables(s)
	}
}

func (s *ListTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTables(s)
	}
}

type DefineVariableContext struct {
	*StatementContext
}

func NewDefineVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefineVariableContext {
	var p = new(DefineVariableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DefineVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineVariableContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDEFINE, 0)
}

func (s *DefineVariableContext) VariableName() IVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *DefineVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *DefineVariableContext) VariableValue() IVariableValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableValueContext)
}

func (s *DefineVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDefineVariable(s)
	}
}

func (s *DefineVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDefineVariable(s)
	}
}

type ExplainContext struct {
	*StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitExplain(s)
	}
}

type CreateTableContext struct {
	*StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *CreateTableContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateTableContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateTableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateTableContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateTableContext) TableElements() ITableElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *CreateTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateTableContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type UnsetPropertyContext struct {
	*StatementContext
}

func NewUnsetPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsetPropertyContext {
	var p = new(UnsetPropertyContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *UnsetPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetPropertyContext) UNSET() antlr.TerminalNode {
	return s.GetToken(KSqlParserUNSET, 0)
}

func (s *UnsetPropertyContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *UnsetPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUnsetProperty(s)
	}
}

func (s *UnsetPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUnsetProperty(s)
	}
}

type ListTypesContext struct {
	*StatementContext
}

func NewListTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTypesContext {
	var p = new(ListTypesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTypesContext) TYPES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPES, 0)
}

func (s *ListTypesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTypesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTypes(s)
	}
}

func (s *ListTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTypes(s)
	}
}

type DescribeFunctionContext struct {
	*StatementContext
}

func NewDescribeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeFunctionContext {
	var p = new(DescribeFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeFunctionContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTION, 0)
}

func (s *DescribeFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeFunction(s)
	}
}

func (s *DescribeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeFunction(s)
	}
}

type RegisterTypeContext struct {
	*StatementContext
}

func NewRegisterTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegisterTypeContext {
	var p = new(RegisterTypeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RegisterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegisterTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *RegisterTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *RegisterTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RegisterTypeContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *RegisterTypeContext) Sqltype() ISqltypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqltypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *RegisterTypeContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *RegisterTypeContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *RegisterTypeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *RegisterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRegisterType(s)
	}
}

func (s *RegisterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRegisterType(s)
	}
}

type ListTopicsContext struct {
	*StatementContext
}

func NewListTopicsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTopicsContext {
	var p = new(ListTopicsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTopicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTopicsContext) TOPICS() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPICS, 0)
}

func (s *ListTopicsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTopicsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTopicsContext) ALL() antlr.TerminalNode {
	return s.GetToken(KSqlParserALL, 0)
}

func (s *ListTopicsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListTopicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTopics(s)
	}
}

func (s *ListTopicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTopics(s)
	}
}

type ListQueriesContext struct {
	*StatementContext
}

func NewListQueriesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListQueriesContext {
	var p = new(ListQueriesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListQueriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListQueriesContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(KSqlParserQUERIES, 0)
}

func (s *ListQueriesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListQueriesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListQueriesContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListQueriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListQueries(s)
	}
}

func (s *ListQueriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListQueries(s)
	}
}

type DropStreamContext struct {
	*StatementContext
}

func NewDropStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStreamContext {
	var p = new(DropStreamContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStreamContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *DropStreamContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *DropStreamContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropStreamContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropStreamContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDELETE, 0)
}

func (s *DropStreamContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPIC, 0)
}

func (s *DropStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropStream(s)
	}
}

func (s *DropStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropStream(s)
	}
}

type QueryStatementContext struct {
	*StatementContext
}

func NewQueryStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryStatementContext {
	var p = new(QueryStatementContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

type CreateStreamAsContext struct {
	*StatementContext
}

func NewCreateStreamAsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStreamAsContext {
	var p = new(CreateStreamAsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateStreamAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStreamAsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateStreamAsContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *CreateStreamAsContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateStreamAsContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CreateStreamAsContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateStreamAsContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateStreamAsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateStreamAsContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateStreamAsContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateStreamAsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateStreamAsContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateStreamAsContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateStreamAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateStreamAs(s)
	}
}

func (s *CreateStreamAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateStreamAs(s)
	}
}

type CreateTableAsContext struct {
	*StatementContext
}

func NewCreateTableAsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsContext {
	var p = new(CreateTableAsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateTableAsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *CreateTableAsContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateTableAsContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CreateTableAsContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableAsContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateTableAsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateTableAsContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateTableAsContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateTableAsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateTableAsContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateTableAsContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateTableAs(s)
	}
}

func (s *CreateTableAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateTableAs(s)
	}
}

type CreateConnectorContext struct {
	*StatementContext
}

func NewCreateConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateConnectorContext {
	var p = new(CreateConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateConnectorContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *CreateConnectorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateConnectorContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateConnectorContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateConnectorContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *CreateConnectorContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateConnectorContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateConnectorContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateConnectorContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateConnector(s)
	}
}

func (s *CreateConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateConnector(s)
	}
}

type CreateStreamContext struct {
	*StatementContext
}

func NewCreateStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStreamContext {
	var p = new(CreateStreamContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStreamContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *CreateStreamContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateStreamContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateStreamContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateStreamContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateStreamContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateStreamContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateStreamContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateStreamContext) TableElements() ITableElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *CreateStreamContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateStreamContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateStream(s)
	}
}

func (s *CreateStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateStream(s)
	}
}

type ListConnectorsContext struct {
	*StatementContext
}

func NewListConnectorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListConnectorsContext {
	var p = new(ListConnectorsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListConnectorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListConnectorsContext) CONNECTORS() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTORS, 0)
}

func (s *ListConnectorsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListConnectorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListConnectorsContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *ListConnectorsContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *ListConnectorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListConnectors(s)
	}
}

func (s *ListConnectorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListConnectors(s)
	}
}

type ListVariablesContext struct {
	*StatementContext
}

func NewListVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListVariablesContext {
	var p = new(ListVariablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListVariablesContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLES, 0)
}

func (s *ListVariablesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListVariablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListVariables(s)
	}
}

func (s *ListVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListVariables(s)
	}
}

type ListStreamsContext struct {
	*StatementContext
}

func NewListStreamsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListStreamsContext {
	var p = new(ListStreamsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListStreamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListStreamsContext) STREAMS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAMS, 0)
}

func (s *ListStreamsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListStreamsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListStreamsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListStreamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListStreams(s)
	}
}

func (s *ListStreamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListStreams(s)
	}
}

type ShowColumnsContext struct {
	*StatementContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *ShowColumnsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type DropTableContext struct {
	*StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *DropTableContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropTableContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDELETE, 0)
}

func (s *DropTableContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPIC, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type DropConnectorContext struct {
	*StatementContext
}

func NewDropConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropConnectorContext {
	var p = new(DropConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConnectorContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *DropConnectorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropConnectorContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropConnectorContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropConnector(s)
	}
}

func (s *DropConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropConnector(s)
	}
}

type ListConnectorPluginsContext struct {
	*StatementContext
}

func NewListConnectorPluginsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListConnectorPluginsContext {
	var p = new(ListConnectorPluginsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListConnectorPluginsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListConnectorPluginsContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *ListConnectorPluginsContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUGINS, 0)
}

func (s *ListConnectorPluginsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListConnectorPluginsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListConnectorPluginsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListConnectorPlugins(s)
	}
}

func (s *ListConnectorPluginsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListConnectorPlugins(s)
	}
}

type ListFunctionsContext struct {
	*StatementContext
}

func NewListFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListFunctionsContext {
	var p = new(ListFunctionsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTIONS, 0)
}

func (s *ListFunctionsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListFunctions(s)
	}
}

func (s *ListFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListFunctions(s)
	}
}

type DescribeConnectorContext struct {
	*StatementContext
}

func NewDescribeConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeConnectorContext {
	var p = new(DescribeConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeConnectorContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *DescribeConnectorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeConnector(s)
	}
}

func (s *DescribeConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeConnector(s)
	}
}

type InsertIntoContext struct {
	*StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserINSERT, 0)
}

func (s *InsertIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTO, 0)
}

func (s *InsertIntoContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *InsertIntoContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertIntoContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *InsertIntoContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

type AlterSourceContext struct {
	*StatementContext
}

func NewAlterSourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSourceContext {
	var p = new(AlterSourceContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AlterSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSourceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserALTER, 0)
}

func (s *AlterSourceContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AlterSourceContext) AllAlterOption() []IAlterOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterOptionContext); ok {
			len++
		}
	}

	tst := make([]IAlterOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterOptionContext); ok {
			tst[i] = t.(IAlterOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterSourceContext) AlterOption(i int) IAlterOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterOptionContext)
}

func (s *AlterSourceContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *AlterSourceContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *AlterSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAlterSource(s)
	}
}

func (s *AlterSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAlterSource(s)
	}
}

type PrintTopicContext struct {
	*StatementContext
}

func NewPrintTopicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrintTopicContext {
	var p = new(PrintTopicContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *PrintTopicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintTopicContext) PRINT() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRINT, 0)
}

func (s *PrintTopicContext) PrintClause() IPrintClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintClauseContext)
}

func (s *PrintTopicContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrintTopicContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *PrintTopicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPrintTopic(s)
	}
}

func (s *PrintTopicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPrintTopic(s)
	}
}

type ListPropertiesContext struct {
	*StatementContext
}

func NewListPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListPropertiesContext {
	var p = new(ListPropertiesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(KSqlParserPROPERTIES, 0)
}

func (s *ListPropertiesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListProperties(s)
	}
}

func (s *ListPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListProperties(s)
	}
}

type DropTypeContext struct {
	*StatementContext
}

func NewDropTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTypeContext {
	var p = new(DropTypeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTypeContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *DropTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTypeContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropTypeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropType(s)
	}
}

func (s *DropTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropType(s)
	}
}

type SetPropertyContext struct {
	*StatementContext
}

func NewSetPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPropertyContext {
	var p = new(SetPropertyContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPropertyContext) SET() antlr.TerminalNode {
	return s.GetToken(KSqlParserSET, 0)
}

func (s *SetPropertyContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserSTRING)
}

func (s *SetPropertyContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, i)
}

func (s *SetPropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *SetPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSetProperty(s)
	}
}

func (s *SetPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSetProperty(s)
	}
}

type TerminateQueryContext struct {
	*StatementContext
}

func NewTerminateQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TerminateQueryContext {
	var p = new(TerminateQueryContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *TerminateQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminateQueryContext) TERMINATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTERMINATE, 0)
}

func (s *TerminateQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TerminateQueryContext) ALL() antlr.TerminalNode {
	return s.GetToken(KSqlParserALL, 0)
}

func (s *TerminateQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTerminateQuery(s)
	}
}

func (s *TerminateQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTerminateQuery(s)
	}
}

type UndefineVariableContext struct {
	*StatementContext
}

func NewUndefineVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UndefineVariableContext {
	var p = new(UndefineVariableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *UndefineVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UndefineVariableContext) UNDEFINE() antlr.TerminalNode {
	return s.GetToken(KSqlParserUNDEFINE, 0)
}

func (s *UndefineVariableContext) VariableName() IVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *UndefineVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUndefineVariable(s)
	}
}

func (s *UndefineVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUndefineVariable(s)
	}
}

type InsertValuesContext struct {
	*StatementContext
}

func NewInsertValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertValuesContext {
	var p = new(InsertValuesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserINSERT, 0)
}

func (s *InsertValuesContext) INTO() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTO, 0)
}

func (s *InsertValuesContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *InsertValuesContext) VALUES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, 0)
}

func (s *InsertValuesContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *InsertValuesContext) Columns() IColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *InsertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInsertValues(s)
	}
}

func (s *InsertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInsertValues(s)
	}
}

type DescribeStreamsContext struct {
	*StatementContext
}

func NewDescribeStreamsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeStreamsContext {
	var p = new(DescribeStreamsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeStreamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStreamsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeStreamsContext) STREAMS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAMS, 0)
}

func (s *DescribeStreamsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *DescribeStreamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeStreams(s)
	}
}

func (s *DescribeStreamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeStreams(s)
	}
}

func (p *KSqlParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KSqlParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQueryStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(148)
			p.Query()
		}

	case 2:
		localctx = NewListPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(149)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(150)
			p.Match(KSqlParserPROPERTIES)
		}

	case 3:
		localctx = NewListTopicsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(151)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(153)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserALL {
			{
				p.SetState(152)
				p.Match(KSqlParserALL)
			}

		}
		{
			p.SetState(155)
			p.Match(KSqlParserTOPICS)
		}
		p.SetState(157)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(156)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 4:
		localctx = NewListStreamsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(159)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(160)
			p.Match(KSqlParserSTREAMS)
		}
		p.SetState(162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(161)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 5:
		localctx = NewListTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(164)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(165)
			p.Match(KSqlParserTABLES)
		}
		p.SetState(167)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(166)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 6:
		localctx = NewListFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(169)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(170)
			p.Match(KSqlParserFUNCTIONS)
		}

	case 7:
		localctx = NewListConnectorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(171)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(173)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSINK || _la == KSqlParserSOURCE {
			{
				p.SetState(172)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KSqlParserSINK || _la == KSqlParserSOURCE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(175)
			p.Match(KSqlParserCONNECTORS)
		}

	case 8:
		localctx = NewListConnectorPluginsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(176)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(177)
			p.Match(KSqlParserCONNECTOR)
		}
		{
			p.SetState(178)
			p.Match(KSqlParserPLUGINS)
		}

	case 9:
		localctx = NewListTypesContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(179)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(180)
			p.Match(KSqlParserTYPES)
		}

	case 10:
		localctx = NewListVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(181)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(182)
			p.Match(KSqlParserVARIABLES)
		}

	case 11:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(183)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(184)
			p.SourceName()
		}
		p.SetState(186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(185)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 12:
		localctx = NewDescribeStreamsContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(188)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(189)
			p.Match(KSqlParserSTREAMS)
		}
		p.SetState(191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(190)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 13:
		localctx = NewDescribeFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(193)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(194)
			p.Match(KSqlParserFUNCTION)
		}
		{
			p.SetState(195)
			p.Identifier()
		}

	case 14:
		localctx = NewDescribeConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(196)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(197)
			p.Match(KSqlParserCONNECTOR)
		}
		{
			p.SetState(198)
			p.Identifier()
		}

	case 15:
		localctx = NewPrintTopicContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(199)
			p.Match(KSqlParserPRINT)
		}
		p.SetState(202)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
			{
				p.SetState(200)
				p.Identifier()
			}

		case KSqlParserSTRING:
			{
				p.SetState(201)
				p.Match(KSqlParserSTRING)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(204)
			p.PrintClause()
		}

	case 16:
		localctx = NewListQueriesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(205)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(206)
			p.Match(KSqlParserQUERIES)
		}
		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(207)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 17:
		localctx = NewTerminateQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(210)
			p.Match(KSqlParserTERMINATE)
		}
		{
			p.SetState(211)
			p.Identifier()
		}

	case 18:
		localctx = NewTerminateQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(212)
			p.Match(KSqlParserTERMINATE)
		}
		{
			p.SetState(213)
			p.Match(KSqlParserALL)
		}

	case 19:
		localctx = NewSetPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(214)
			p.Match(KSqlParserSET)
		}
		{
			p.SetState(215)
			p.Match(KSqlParserSTRING)
		}
		{
			p.SetState(216)
			p.Match(KSqlParserEQ)
		}
		{
			p.SetState(217)
			p.Match(KSqlParserSTRING)
		}

	case 20:
		localctx = NewUnsetPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(218)
			p.Match(KSqlParserUNSET)
		}
		{
			p.SetState(219)
			p.Match(KSqlParserSTRING)
		}

	case 21:
		localctx = NewDefineVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(220)
			p.Match(KSqlParserDEFINE)
		}
		{
			p.SetState(221)
			p.VariableName()
		}
		{
			p.SetState(222)
			p.Match(KSqlParserEQ)
		}
		{
			p.SetState(223)
			p.VariableValue()
		}

	case 22:
		localctx = NewUndefineVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(225)
			p.Match(KSqlParserUNDEFINE)
		}
		{
			p.SetState(226)
			p.VariableName()
		}

	case 23:
		localctx = NewCreateStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(227)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(228)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(229)
				p.Match(KSqlParserREPLACE)
			}

		}
		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSOURCE {
			{
				p.SetState(232)
				p.Match(KSqlParserSOURCE)
			}

		}
		{
			p.SetState(235)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(236)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(237)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(238)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(241)
			p.SourceName()
		}
		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(242)
				p.TableElements()
			}

		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(245)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(246)
				p.TableProperties()
			}

		}

	case 24:
		localctx = NewCreateStreamAsContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(249)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(250)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(251)
				p.Match(KSqlParserREPLACE)
			}

		}
		{
			p.SetState(254)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(258)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(255)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(256)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(257)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(260)
			p.SourceName()
		}
		p.SetState(263)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(261)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(262)
				p.TableProperties()
			}

		}
		{
			p.SetState(265)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(266)
			p.Query()
		}

	case 25:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(268)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(271)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(269)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(270)
				p.Match(KSqlParserREPLACE)
			}

		}
		p.SetState(274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSOURCE {
			{
				p.SetState(273)
				p.Match(KSqlParserSOURCE)
			}

		}
		{
			p.SetState(276)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(280)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(277)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(278)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(279)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(282)
			p.SourceName()
		}
		p.SetState(284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(283)
				p.TableElements()
			}

		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(286)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(287)
				p.TableProperties()
			}

		}

	case 26:
		localctx = NewCreateTableAsContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(290)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(291)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(292)
				p.Match(KSqlParserREPLACE)
			}

		}
		{
			p.SetState(295)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(299)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(296)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(297)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(298)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(301)
			p.SourceName()
		}
		p.SetState(304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(302)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(303)
				p.TableProperties()
			}

		}
		{
			p.SetState(306)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(307)
			p.Query()
		}

	case 27:
		localctx = NewCreateConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(309)
			p.Match(KSqlParserCREATE)
		}
		{
			p.SetState(310)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSINK || _la == KSqlParserSOURCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(311)
			p.Match(KSqlParserCONNECTOR)
		}
		p.SetState(315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(312)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(313)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(314)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(317)
			p.Identifier()
		}
		{
			p.SetState(318)
			p.Match(KSqlParserWITH)
		}
		{
			p.SetState(319)
			p.TableProperties()
		}

	case 28:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(321)
			p.Match(KSqlParserINSERT)
		}
		{
			p.SetState(322)
			p.Match(KSqlParserINTO)
		}
		{
			p.SetState(323)
			p.SourceName()
		}
		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(324)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(325)
				p.TableProperties()
			}

		}
		{
			p.SetState(328)
			p.Query()
		}

	case 29:
		localctx = NewInsertValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(330)
			p.Match(KSqlParserINSERT)
		}
		{
			p.SetState(331)
			p.Match(KSqlParserINTO)
		}
		{
			p.SetState(332)
			p.SourceName()
		}
		p.SetState(334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(333)
				p.Columns()
			}

		}
		{
			p.SetState(336)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(337)
			p.Values()
		}

	case 30:
		localctx = NewDropStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(339)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(340)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(343)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(341)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(342)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(345)
			p.SourceName()
		}
		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserDELETE {
			{
				p.SetState(346)
				p.Match(KSqlParserDELETE)
			}
			{
				p.SetState(347)
				p.Match(KSqlParserTOPIC)
			}

		}

	case 31:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(350)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(351)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(354)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(352)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(353)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(356)
			p.SourceName()
		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserDELETE {
			{
				p.SetState(357)
				p.Match(KSqlParserDELETE)
			}
			{
				p.SetState(358)
				p.Match(KSqlParserTOPIC)
			}

		}

	case 32:
		localctx = NewDropConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(361)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(362)
			p.Match(KSqlParserCONNECTOR)
		}
		p.SetState(365)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(363)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(364)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(367)
			p.Identifier()
		}

	case 33:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(368)
			p.Match(KSqlParserEXPLAIN)
		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(369)
				p.Statement()
			}

		case 2:
			{
				p.SetState(370)
				p.Identifier()
			}

		}

	case 34:
		localctx = NewRegisterTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(373)
			p.Match(KSqlParserCREATE)
		}
		{
			p.SetState(374)
			p.Match(KSqlParserTYPE)
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(375)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(376)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(377)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(380)
			p.Identifier()
		}
		{
			p.SetState(381)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(382)
			p.sqltype(0)
		}

	case 35:
		localctx = NewDropTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(384)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(385)
			p.Match(KSqlParserTYPE)
		}
		p.SetState(388)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(386)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(387)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(390)
			p.Identifier()
		}

	case 36:
		localctx = NewAlterSourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(391)
			p.Match(KSqlParserALTER)
		}
		{
			p.SetState(392)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserTABLE || _la == KSqlParserSTREAM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(393)
			p.SourceName()
		}
		{
			p.SetState(394)
			p.AlterOption()
		}
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(395)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(396)
				p.AlterOption()
			}

			p.SetState(401)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_assertStatement
	return p
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) CopyFrom(ctx *AssertStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AssertValuesContext struct {
	*AssertStatementContext
}

func NewAssertValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertValuesContext {
	var p = new(AssertValuesContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertValuesContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertValuesContext) AllVALUES() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserVALUES)
}

func (s *AssertValuesContext) VALUES(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, i)
}

func (s *AssertValuesContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertValuesContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *AssertValuesContext) Columns() IColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *AssertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertValues(s)
	}
}

func (s *AssertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertValues(s)
	}
}

type AssertTombstoneContext struct {
	*AssertStatementContext
}

func NewAssertTombstoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTombstoneContext {
	var p = new(AssertTombstoneContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertTombstoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTombstoneContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertTombstoneContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *AssertTombstoneContext) VALUES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, 0)
}

func (s *AssertTombstoneContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertTombstoneContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *AssertTombstoneContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *AssertTombstoneContext) Columns() IColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *AssertTombstoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertTombstone(s)
	}
}

func (s *AssertTombstoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertTombstone(s)
	}
}

type AssertTableContext struct {
	*AssertStatementContext
}

func NewAssertTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTableContext {
	var p = new(AssertTableContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTableContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *AssertTableContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertTableContext) TableElements() ITableElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *AssertTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *AssertTableContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertTable(s)
	}
}

func (s *AssertTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertTable(s)
	}
}

type AssertStreamContext struct {
	*AssertStatementContext
}

func NewAssertStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertStreamContext {
	var p = new(AssertStreamContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStreamContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *AssertStreamContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertStreamContext) TableElements() ITableElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *AssertStreamContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *AssertStreamContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertStream(s)
	}
}

func (s *AssertStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertStream(s)
	}
}

func (p *KSqlParser) AssertStatement() (localctx IAssertStatementContext) {
	this := p
	_ = this

	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KSqlParserRULE_assertStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAssertValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(404)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(405)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(406)
			p.SourceName()
		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(407)
				p.Columns()
			}

		}
		{
			p.SetState(410)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(411)
			p.Values()
		}

	case 2:
		localctx = NewAssertTombstoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(413)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(414)
			p.Match(KSqlParserNULL)
		}
		{
			p.SetState(415)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(416)
			p.SourceName()
		}
		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(417)
				p.Columns()
			}

		}
		{
			p.SetState(420)
			p.Match(KSqlParserKEY)
		}
		{
			p.SetState(421)
			p.Values()
		}

	case 3:
		localctx = NewAssertStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(423)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(424)
			p.Match(KSqlParserSTREAM)
		}
		{
			p.SetState(425)
			p.SourceName()
		}
		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(426)
				p.TableElements()
			}

		}
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(429)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(430)
				p.TableProperties()
			}

		}

	case 4:
		localctx = NewAssertTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(433)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(434)
			p.Match(KSqlParserTABLE)
		}
		{
			p.SetState(435)
			p.SourceName()
		}
		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(436)
				p.TableElements()
			}

		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(439)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(440)
				p.TableProperties()
			}

		}

	}

	return localctx
}

// IRunScriptContext is an interface to support dynamic dispatch.
type IRunScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RUN() antlr.TerminalNode
	SCRIPT() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsRunScriptContext differentiates from other interfaces.
	IsRunScriptContext()
}

type RunScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRunScriptContext() *RunScriptContext {
	var p = new(RunScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_runScript
	return p
}

func (*RunScriptContext) IsRunScriptContext() {}

func NewRunScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RunScriptContext {
	var p = new(RunScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_runScript

	return p
}

func (s *RunScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *RunScriptContext) RUN() antlr.TerminalNode {
	return s.GetToken(KSqlParserRUN, 0)
}

func (s *RunScriptContext) SCRIPT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSCRIPT, 0)
}

func (s *RunScriptContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *RunScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RunScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RunScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRunScript(s)
	}
}

func (s *RunScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRunScript(s)
	}
}

func (p *KSqlParser) RunScript() (localctx IRunScriptContext) {
	this := p
	_ = this

	localctx = NewRunScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KSqlParserRULE_runScript)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.Match(KSqlParserRUN)
	}
	{
		p.SetState(446)
		p.Match(KSqlParserSCRIPT)
	}
	{
		p.SetState(447)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IRelationContext

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetFrom sets the from rule contexts.
	SetFrom(IRelationContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FROM() antlr.TerminalNode
	Relation() IRelationContext
	WINDOW() antlr.TerminalNode
	WindowExpression() IWindowExpressionContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	GroupBy() IGroupByContext
	PARTITION() antlr.TerminalNode
	PartitionBy() IPartitionByContext
	HAVING() antlr.TerminalNode
	EMIT() antlr.TerminalNode
	ResultMaterialization() IResultMaterializationContext
	LimitClause() ILimitClauseContext
	AllBooleanExpression() []IBooleanExpressionContext
	BooleanExpression(i int) IBooleanExpressionContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IRelationContext
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) GetFrom() IRelationContext { return s.from }

func (s *QueryContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QueryContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QueryContext) SetFrom(v IRelationContext) { s.from = v }

func (s *QueryContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QueryContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QueryContext) SELECT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSELECT, 0)
}

func (s *QueryContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QueryContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *QueryContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QueryContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserWINDOW, 0)
}

func (s *QueryContext) WindowExpression() IWindowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowExpressionContext)
}

func (s *QueryContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KSqlParserWHERE, 0)
}

func (s *QueryContext) GROUP() antlr.TerminalNode {
	return s.GetToken(KSqlParserGROUP, 0)
}

func (s *QueryContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserBY)
}

func (s *QueryContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserBY, i)
}

func (s *QueryContext) GroupBy() IGroupByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QueryContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITION, 0)
}

func (s *QueryContext) PartitionBy() IPartitionByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionByContext)
}

func (s *QueryContext) HAVING() antlr.TerminalNode {
	return s.GetToken(KSqlParserHAVING, 0)
}

func (s *QueryContext) EMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserEMIT, 0)
}

func (s *QueryContext) ResultMaterialization() IResultMaterializationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultMaterializationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultMaterializationContext)
}

func (s *QueryContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QueryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *KSqlParser) Query() (localctx IQueryContext) {
	this := p
	_ = this

	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KSqlParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(KSqlParserSELECT)
	}
	{
		p.SetState(450)
		p.SelectItem()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(451)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(452)
			p.SelectItem()
		}

		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(458)
		p.Match(KSqlParserFROM)
	}
	{
		p.SetState(459)

		var _x = p.Relation()

		localctx.(*QueryContext).from = _x
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWINDOW {
		{
			p.SetState(460)
			p.Match(KSqlParserWINDOW)
		}
		{
			p.SetState(461)
			p.WindowExpression()
		}

	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWHERE {
		{
			p.SetState(464)
			p.Match(KSqlParserWHERE)
		}
		{
			p.SetState(465)

			var _x = p.booleanExpression(0)

			localctx.(*QueryContext).where = _x
		}

	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserGROUP {
		{
			p.SetState(468)
			p.Match(KSqlParserGROUP)
		}
		{
			p.SetState(469)
			p.Match(KSqlParserBY)
		}
		{
			p.SetState(470)
			p.GroupBy()
		}

	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserPARTITION {
		{
			p.SetState(473)
			p.Match(KSqlParserPARTITION)
		}
		{
			p.SetState(474)
			p.Match(KSqlParserBY)
		}
		{
			p.SetState(475)
			p.PartitionBy()
		}

	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserHAVING {
		{
			p.SetState(478)
			p.Match(KSqlParserHAVING)
		}
		{
			p.SetState(479)

			var _x = p.booleanExpression(0)

			localctx.(*QueryContext).having = _x
		}

	}
	p.SetState(484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserEMIT {
		{
			p.SetState(482)
			p.Match(KSqlParserEMIT)
		}
		{
			p.SetState(483)
			p.ResultMaterialization()
		}

	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserLIMIT {
		{
			p.SetState(486)
			p.LimitClause()
		}

	}

	return localctx
}

// IResultMaterializationContext is an interface to support dynamic dispatch.
type IResultMaterializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGES() antlr.TerminalNode
	FINAL() antlr.TerminalNode

	// IsResultMaterializationContext differentiates from other interfaces.
	IsResultMaterializationContext()
}

type ResultMaterializationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultMaterializationContext() *ResultMaterializationContext {
	var p = new(ResultMaterializationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_resultMaterialization
	return p
}

func (*ResultMaterializationContext) IsResultMaterializationContext() {}

func NewResultMaterializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultMaterializationContext {
	var p = new(ResultMaterializationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_resultMaterialization

	return p
}

func (s *ResultMaterializationContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultMaterializationContext) CHANGES() antlr.TerminalNode {
	return s.GetToken(KSqlParserCHANGES, 0)
}

func (s *ResultMaterializationContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFINAL, 0)
}

func (s *ResultMaterializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultMaterializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultMaterializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterResultMaterialization(s)
	}
}

func (s *ResultMaterializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitResultMaterialization(s)
	}
}

func (p *KSqlParser) ResultMaterialization() (localctx IResultMaterializationContext) {
	this := p
	_ = this

	localctx = NewResultMaterializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KSqlParserRULE_resultMaterialization)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserCHANGES || _la == KSqlParserFINAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAlterOptionContext is an interface to support dynamic dispatch.
type IAlterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Identifier() IIdentifierContext
	Sqltype() ISqltypeContext
	COLUMN() antlr.TerminalNode

	// IsAlterOptionContext differentiates from other interfaces.
	IsAlterOptionContext()
}

type AlterOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterOptionContext() *AlterOptionContext {
	var p = new(AlterOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_alterOption
	return p
}

func (*AlterOptionContext) IsAlterOptionContext() {}

func NewAlterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterOptionContext {
	var p = new(AlterOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_alterOption

	return p
}

func (s *AlterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterOptionContext) ADD() antlr.TerminalNode {
	return s.GetToken(KSqlParserADD, 0)
}

func (s *AlterOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterOptionContext) Sqltype() ISqltypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqltypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *AlterOptionContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMN, 0)
}

func (s *AlterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAlterOption(s)
	}
}

func (s *AlterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAlterOption(s)
	}
}

func (p *KSqlParser) AlterOption() (localctx IAlterOptionContext) {
	this := p
	_ = this

	localctx = NewAlterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KSqlParserRULE_alterOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(KSqlParserADD)
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(492)
			p.Match(KSqlParserCOLUMN)
		}

	}
	{
		p.SetState(495)
		p.Identifier()
	}
	{
		p.SetState(496)
		p.sqltype(0)
	}

	return localctx
}

// ITableElementsContext is an interface to support dynamic dispatch.
type ITableElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableElement() []ITableElementContext
	TableElement(i int) ITableElementContext

	// IsTableElementsContext differentiates from other interfaces.
	IsTableElementsContext()
}

type TableElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementsContext() *TableElementsContext {
	var p = new(TableElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableElements
	return p
}

func (*TableElementsContext) IsTableElementsContext() {}

func NewTableElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementsContext {
	var p = new(TableElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableElements

	return p
}

func (s *TableElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementsContext) AllTableElement() []ITableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableElementContext); ok {
			len++
		}
	}

	tst := make([]ITableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableElementContext); ok {
			tst[i] = t.(ITableElementContext)
			i++
		}
	}

	return tst
}

func (s *TableElementsContext) TableElement(i int) ITableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *TableElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableElements(s)
	}
}

func (s *TableElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableElements(s)
	}
}

func (p *KSqlParser) TableElements() (localctx ITableElementsContext) {
	this := p
	_ = this

	localctx = NewTableElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KSqlParserRULE_tableElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(499)
		p.TableElement()
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(500)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(501)
			p.TableElement()
		}

		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(507)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Sqltype() ISqltypeContext
	ColumnConstraints() IColumnConstraintsContext

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableElement
	return p
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableElementContext) Sqltype() ISqltypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqltypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *TableElementContext) ColumnConstraints() IColumnConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintsContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (p *KSqlParser) TableElement() (localctx ITableElementContext) {
	this := p
	_ = this

	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KSqlParserRULE_tableElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Identifier()
	}
	{
		p.SetState(510)
		p.sqltype(0)
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&98561) != 0 {
		{
			p.SetState(511)
			p.ColumnConstraints()
		}

	}

	return localctx
}

// IColumnConstraintsContext is an interface to support dynamic dispatch.
type IColumnConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	HEADERS() antlr.TerminalNode
	HEADER() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsColumnConstraintsContext differentiates from other interfaces.
	IsColumnConstraintsContext()
}

type ColumnConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintsContext() *ColumnConstraintsContext {
	var p = new(ColumnConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_columnConstraints
	return p
}

func (*ColumnConstraintsContext) IsColumnConstraintsContext() {}

func NewColumnConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintsContext {
	var p = new(ColumnConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_columnConstraints

	return p
}

func (s *ColumnConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintsContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *ColumnConstraintsContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRIMARY, 0)
}

func (s *ColumnConstraintsContext) HEADERS() antlr.TerminalNode {
	return s.GetToken(KSqlParserHEADERS, 0)
}

func (s *ColumnConstraintsContext) HEADER() antlr.TerminalNode {
	return s.GetToken(KSqlParserHEADER, 0)
}

func (s *ColumnConstraintsContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *ColumnConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterColumnConstraints(s)
	}
}

func (s *ColumnConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitColumnConstraints(s)
	}
}

func (p *KSqlParser) ColumnConstraints() (localctx IColumnConstraintsContext) {
	this := p
	_ = this

	localctx = NewColumnConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KSqlParserRULE_columnConstraints)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(523)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserKEY, KSqlParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserPRIMARY {
			{
				p.SetState(514)
				p.Match(KSqlParserPRIMARY)
			}

		}
		{
			p.SetState(517)
			p.Match(KSqlParserKEY)
		}

	case KSqlParserHEADERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(518)
			p.Match(KSqlParserHEADERS)
		}

	case KSqlParserHEADER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(519)
			p.Match(KSqlParserHEADER)
		}
		{
			p.SetState(520)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(521)
			p.Match(KSqlParserSTRING)
		}
		{
			p.SetState(522)
			p.Match(KSqlParserT__3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITablePropertiesContext is an interface to support dynamic dispatch.
type ITablePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableProperty() []ITablePropertyContext
	TableProperty(i int) ITablePropertyContext

	// IsTablePropertiesContext differentiates from other interfaces.
	IsTablePropertiesContext()
}

type TablePropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesContext() *TablePropertiesContext {
	var p = new(TablePropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableProperties
	return p
}

func (*TablePropertiesContext) IsTablePropertiesContext() {}

func NewTablePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesContext {
	var p = new(TablePropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableProperties

	return p
}

func (s *TablePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesContext) AllTableProperty() []ITablePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablePropertyContext); ok {
			len++
		}
	}

	tst := make([]ITablePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablePropertyContext); ok {
			tst[i] = t.(ITablePropertyContext)
			i++
		}
	}

	return tst
}

func (s *TablePropertiesContext) TableProperty(i int) ITablePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyContext)
}

func (s *TablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableProperties(s)
	}
}

func (s *TablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableProperties(s)
	}
}

func (p *KSqlParser) TableProperties() (localctx ITablePropertiesContext) {
	this := p
	_ = this

	localctx = NewTablePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KSqlParserRULE_tableProperties)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(526)
		p.TableProperty()
	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(527)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(528)
			p.TableProperty()
		}

		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(534)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ITablePropertyContext is an interface to support dynamic dispatch.
type ITablePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	Literal() ILiteralContext
	Identifier() IIdentifierContext
	STRING() antlr.TerminalNode

	// IsTablePropertyContext differentiates from other interfaces.
	IsTablePropertyContext()
}

type TablePropertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyContext() *TablePropertyContext {
	var p = new(TablePropertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableProperty
	return p
}

func (*TablePropertyContext) IsTablePropertyContext() {}

func NewTablePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyContext {
	var p = new(TablePropertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableProperty

	return p
}

func (s *TablePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *TablePropertyContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *TablePropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablePropertyContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TablePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableProperty(s)
	}
}

func (s *TablePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableProperty(s)
	}
}

func (p *KSqlParser) TableProperty() (localctx ITablePropertyContext) {
	this := p
	_ = this

	localctx = NewTablePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KSqlParserRULE_tableProperty)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		{
			p.SetState(536)
			p.Identifier()
		}

	case KSqlParserSTRING:
		{
			p.SetState(537)
			p.Match(KSqlParserSTRING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(540)
		p.Match(KSqlParserEQ)
	}
	{
		p.SetState(541)
		p.Literal()
	}

	return localctx
}

// IPrintClauseContext is an interface to support dynamic dispatch.
type IPrintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	BEGINNING() antlr.TerminalNode
	IntervalClause() IIntervalClauseContext
	LimitClause() ILimitClauseContext

	// IsPrintClauseContext differentiates from other interfaces.
	IsPrintClauseContext()
}

type PrintClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintClauseContext() *PrintClauseContext {
	var p = new(PrintClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_printClause
	return p
}

func (*PrintClauseContext) IsPrintClauseContext() {}

func NewPrintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintClauseContext {
	var p = new(PrintClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_printClause

	return p
}

func (s *PrintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *PrintClauseContext) BEGINNING() antlr.TerminalNode {
	return s.GetToken(KSqlParserBEGINNING, 0)
}

func (s *PrintClauseContext) IntervalClause() IIntervalClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalClauseContext)
}

func (s *PrintClauseContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *PrintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPrintClause(s)
	}
}

func (s *PrintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPrintClause(s)
	}
}

func (p *KSqlParser) PrintClause() (localctx IPrintClauseContext) {
	this := p
	_ = this

	localctx = NewPrintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KSqlParserRULE_printClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserFROM {
		{
			p.SetState(543)
			p.Match(KSqlParserFROM)
		}
		{
			p.SetState(544)
			p.Match(KSqlParserBEGINNING)
		}

	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserINTERVAL || _la == KSqlParserSAMPLE {
		{
			p.SetState(547)
			p.IntervalClause()
		}

	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserLIMIT {
		{
			p.SetState(550)
			p.LimitClause()
		}

	}

	return localctx
}

// IIntervalClauseContext is an interface to support dynamic dispatch.
type IIntervalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	INTERVAL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode

	// IsIntervalClauseContext differentiates from other interfaces.
	IsIntervalClauseContext()
}

type IntervalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalClauseContext() *IntervalClauseContext {
	var p = new(IntervalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_intervalClause
	return p
}

func (*IntervalClauseContext) IsIntervalClauseContext() {}

func NewIntervalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalClauseContext {
	var p = new(IntervalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_intervalClause

	return p
}

func (s *IntervalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalClauseContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *IntervalClauseContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTERVAL, 0)
}

func (s *IntervalClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSAMPLE, 0)
}

func (s *IntervalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterIntervalClause(s)
	}
}

func (s *IntervalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitIntervalClause(s)
	}
}

func (p *KSqlParser) IntervalClause() (localctx IIntervalClauseContext) {
	this := p
	_ = this

	localctx = NewIntervalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KSqlParserRULE_intervalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserINTERVAL || _la == KSqlParserSAMPLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(554)
		p.Number()
	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	Number() INumberContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIMIT, 0)
}

func (s *LimitClauseContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *KSqlParser) LimitClause() (localctx ILimitClauseContext) {
	this := p
	_ = this

	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KSqlParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Match(KSqlParserLIMIT)
	}
	{
		p.SetState(557)
		p.Number()
	}

	return localctx
}

// IRetentionClauseContext is an interface to support dynamic dispatch.
type IRetentionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETENTION() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext

	// IsRetentionClauseContext differentiates from other interfaces.
	IsRetentionClauseContext()
}

type RetentionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetentionClauseContext() *RetentionClauseContext {
	var p = new(RetentionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_retentionClause
	return p
}

func (*RetentionClauseContext) IsRetentionClauseContext() {}

func NewRetentionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetentionClauseContext {
	var p = new(RetentionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_retentionClause

	return p
}

func (s *RetentionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RetentionClauseContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserRETENTION, 0)
}

func (s *RetentionClauseContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RetentionClauseContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *RetentionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetentionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetentionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRetentionClause(s)
	}
}

func (s *RetentionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRetentionClause(s)
	}
}

func (p *KSqlParser) RetentionClause() (localctx IRetentionClauseContext) {
	this := p
	_ = this

	localctx = NewRetentionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KSqlParserRULE_retentionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(KSqlParserRETENTION)
	}
	{
		p.SetState(560)
		p.Number()
	}
	{
		p.SetState(561)
		p.WindowUnit()
	}

	return localctx
}

// IGracePeriodClauseContext is an interface to support dynamic dispatch.
type IGracePeriodClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRACE() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext

	// IsGracePeriodClauseContext differentiates from other interfaces.
	IsGracePeriodClauseContext()
}

type GracePeriodClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGracePeriodClauseContext() *GracePeriodClauseContext {
	var p = new(GracePeriodClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_gracePeriodClause
	return p
}

func (*GracePeriodClauseContext) IsGracePeriodClauseContext() {}

func NewGracePeriodClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GracePeriodClauseContext {
	var p = new(GracePeriodClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_gracePeriodClause

	return p
}

func (s *GracePeriodClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GracePeriodClauseContext) GRACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserGRACE, 0)
}

func (s *GracePeriodClauseContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KSqlParserPERIOD, 0)
}

func (s *GracePeriodClauseContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *GracePeriodClauseContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *GracePeriodClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GracePeriodClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GracePeriodClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterGracePeriodClause(s)
	}
}

func (s *GracePeriodClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitGracePeriodClause(s)
	}
}

func (p *KSqlParser) GracePeriodClause() (localctx IGracePeriodClauseContext) {
	this := p
	_ = this

	localctx = NewGracePeriodClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KSqlParserRULE_gracePeriodClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(563)
		p.Match(KSqlParserGRACE)
	}
	{
		p.SetState(564)
		p.Match(KSqlParserPERIOD)
	}
	{
		p.SetState(565)
		p.Number()
	}
	{
		p.SetState(566)
		p.WindowUnit()
	}

	return localctx
}

// IWindowExpressionContext is an interface to support dynamic dispatch.
type IWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TumblingWindowExpression() ITumblingWindowExpressionContext
	HoppingWindowExpression() IHoppingWindowExpressionContext
	SessionWindowExpression() ISessionWindowExpressionContext
	IDENTIFIER() antlr.TerminalNode

	// IsWindowExpressionContext differentiates from other interfaces.
	IsWindowExpressionContext()
}

type WindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowExpressionContext() *WindowExpressionContext {
	var p = new(WindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_windowExpression
	return p
}

func (*WindowExpressionContext) IsWindowExpressionContext() {}

func NewWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowExpressionContext {
	var p = new(WindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_windowExpression

	return p
}

func (s *WindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowExpressionContext) TumblingWindowExpression() ITumblingWindowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITumblingWindowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITumblingWindowExpressionContext)
}

func (s *WindowExpressionContext) HoppingWindowExpression() IHoppingWindowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHoppingWindowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHoppingWindowExpressionContext)
}

func (s *WindowExpressionContext) SessionWindowExpression() ISessionWindowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionWindowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionWindowExpressionContext)
}

func (s *WindowExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *WindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWindowExpression(s)
	}
}

func (s *WindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWindowExpression(s)
	}
}

func (p *KSqlParser) WindowExpression() (localctx IWindowExpressionContext) {
	this := p
	_ = this

	localctx = NewWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KSqlParserRULE_windowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserIDENTIFIER {
		{
			p.SetState(568)
			p.Match(KSqlParserIDENTIFIER)
		}

	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserTUMBLING:
		{
			p.SetState(571)
			p.TumblingWindowExpression()
		}

	case KSqlParserHOPPING:
		{
			p.SetState(572)
			p.HoppingWindowExpression()
		}

	case KSqlParserSESSION:
		{
			p.SetState(573)
			p.SessionWindowExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITumblingWindowExpressionContext is an interface to support dynamic dispatch.
type ITumblingWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TUMBLING() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext
	RetentionClause() IRetentionClauseContext
	GracePeriodClause() IGracePeriodClauseContext

	// IsTumblingWindowExpressionContext differentiates from other interfaces.
	IsTumblingWindowExpressionContext()
}

type TumblingWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTumblingWindowExpressionContext() *TumblingWindowExpressionContext {
	var p = new(TumblingWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tumblingWindowExpression
	return p
}

func (*TumblingWindowExpressionContext) IsTumblingWindowExpressionContext() {}

func NewTumblingWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TumblingWindowExpressionContext {
	var p = new(TumblingWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tumblingWindowExpression

	return p
}

func (s *TumblingWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TumblingWindowExpressionContext) TUMBLING() antlr.TerminalNode {
	return s.GetToken(KSqlParserTUMBLING, 0)
}

func (s *TumblingWindowExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSIZE, 0)
}

func (s *TumblingWindowExpressionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *TumblingWindowExpressionContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *TumblingWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetentionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *TumblingWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *TumblingWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TumblingWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TumblingWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTumblingWindowExpression(s)
	}
}

func (s *TumblingWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTumblingWindowExpression(s)
	}
}

func (p *KSqlParser) TumblingWindowExpression() (localctx ITumblingWindowExpressionContext) {
	this := p
	_ = this

	localctx = NewTumblingWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KSqlParserRULE_tumblingWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.Match(KSqlParserTUMBLING)
	}
	{
		p.SetState(577)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(578)
		p.Match(KSqlParserSIZE)
	}
	{
		p.SetState(579)
		p.Number()
	}
	{
		p.SetState(580)
		p.WindowUnit()
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(581)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(582)
			p.RetentionClause()
		}

	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(585)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(586)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(589)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IHoppingWindowExpressionContext is an interface to support dynamic dispatch.
type IHoppingWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOPPING() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	AllNumber() []INumberContext
	Number(i int) INumberContext
	AllWindowUnit() []IWindowUnitContext
	WindowUnit(i int) IWindowUnitContext
	ADVANCE() antlr.TerminalNode
	BY() antlr.TerminalNode
	RetentionClause() IRetentionClauseContext
	GracePeriodClause() IGracePeriodClauseContext

	// IsHoppingWindowExpressionContext differentiates from other interfaces.
	IsHoppingWindowExpressionContext()
}

type HoppingWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHoppingWindowExpressionContext() *HoppingWindowExpressionContext {
	var p = new(HoppingWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_hoppingWindowExpression
	return p
}

func (*HoppingWindowExpressionContext) IsHoppingWindowExpressionContext() {}

func NewHoppingWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HoppingWindowExpressionContext {
	var p = new(HoppingWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_hoppingWindowExpression

	return p
}

func (s *HoppingWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *HoppingWindowExpressionContext) HOPPING() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOPPING, 0)
}

func (s *HoppingWindowExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSIZE, 0)
}

func (s *HoppingWindowExpressionContext) AllNumber() []INumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberContext); ok {
			len++
		}
	}

	tst := make([]INumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberContext); ok {
			tst[i] = t.(INumberContext)
			i++
		}
	}

	return tst
}

func (s *HoppingWindowExpressionContext) Number(i int) INumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *HoppingWindowExpressionContext) AllWindowUnit() []IWindowUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowUnitContext); ok {
			len++
		}
	}

	tst := make([]IWindowUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowUnitContext); ok {
			tst[i] = t.(IWindowUnitContext)
			i++
		}
	}

	return tst
}

func (s *HoppingWindowExpressionContext) WindowUnit(i int) IWindowUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *HoppingWindowExpressionContext) ADVANCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserADVANCE, 0)
}

func (s *HoppingWindowExpressionContext) BY() antlr.TerminalNode {
	return s.GetToken(KSqlParserBY, 0)
}

func (s *HoppingWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetentionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *HoppingWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *HoppingWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HoppingWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HoppingWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterHoppingWindowExpression(s)
	}
}

func (s *HoppingWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitHoppingWindowExpression(s)
	}
}

func (p *KSqlParser) HoppingWindowExpression() (localctx IHoppingWindowExpressionContext) {
	this := p
	_ = this

	localctx = NewHoppingWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KSqlParserRULE_hoppingWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Match(KSqlParserHOPPING)
	}
	{
		p.SetState(592)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(593)
		p.Match(KSqlParserSIZE)
	}
	{
		p.SetState(594)
		p.Number()
	}
	{
		p.SetState(595)
		p.WindowUnit()
	}
	{
		p.SetState(596)
		p.Match(KSqlParserT__1)
	}
	{
		p.SetState(597)
		p.Match(KSqlParserADVANCE)
	}
	{
		p.SetState(598)
		p.Match(KSqlParserBY)
	}
	{
		p.SetState(599)
		p.Number()
	}
	{
		p.SetState(600)
		p.WindowUnit()
	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(601)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(602)
			p.RetentionClause()
		}

	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(605)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(606)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(609)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ISessionWindowExpressionContext is an interface to support dynamic dispatch.
type ISessionWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SESSION() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext
	RetentionClause() IRetentionClauseContext
	GracePeriodClause() IGracePeriodClauseContext

	// IsSessionWindowExpressionContext differentiates from other interfaces.
	IsSessionWindowExpressionContext()
}

type SessionWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionWindowExpressionContext() *SessionWindowExpressionContext {
	var p = new(SessionWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sessionWindowExpression
	return p
}

func (*SessionWindowExpressionContext) IsSessionWindowExpressionContext() {}

func NewSessionWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionWindowExpressionContext {
	var p = new(SessionWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sessionWindowExpression

	return p
}

func (s *SessionWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionWindowExpressionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(KSqlParserSESSION, 0)
}

func (s *SessionWindowExpressionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SessionWindowExpressionContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *SessionWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetentionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *SessionWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *SessionWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSessionWindowExpression(s)
	}
}

func (s *SessionWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSessionWindowExpression(s)
	}
}

func (p *KSqlParser) SessionWindowExpression() (localctx ISessionWindowExpressionContext) {
	this := p
	_ = this

	localctx = NewSessionWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KSqlParserRULE_sessionWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(KSqlParserSESSION)
	}
	{
		p.SetState(612)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(613)
		p.Number()
	}
	{
		p.SetState(614)
		p.WindowUnit()
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(615)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(616)
			p.RetentionClause()
		}

	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(619)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(620)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(623)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IWindowUnitContext is an interface to support dynamic dispatch.
type IWindowUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode

	// IsWindowUnitContext differentiates from other interfaces.
	IsWindowUnitContext()
}

type WindowUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowUnitContext() *WindowUnitContext {
	var p = new(WindowUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_windowUnit
	return p
}

func (*WindowUnitContext) IsWindowUnitContext() {}

func NewWindowUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowUnitContext {
	var p = new(WindowUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_windowUnit

	return p
}

func (s *WindowUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowUnitContext) DAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAY, 0)
}

func (s *WindowUnitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOUR, 0)
}

func (s *WindowUnitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTE, 0)
}

func (s *WindowUnitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECOND, 0)
}

func (s *WindowUnitContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserMILLISECOND, 0)
}

func (s *WindowUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAYS, 0)
}

func (s *WindowUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOURS, 0)
}

func (s *WindowUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTES, 0)
}

func (s *WindowUnitContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECONDS, 0)
}

func (s *WindowUnitContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMILLISECONDS, 0)
}

func (s *WindowUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWindowUnit(s)
	}
}

func (s *WindowUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWindowUnit(s)
	}
}

func (p *KSqlParser) WindowUnit() (localctx IWindowUnitContext) {
	this := p
	_ = this

	localctx = NewWindowUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KSqlParserRULE_windowUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&70351151991619584) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_groupBy
	return p
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupByContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (p *KSqlParser) GroupBy() (localctx IGroupByContext) {
	this := p
	_ = this

	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KSqlParserRULE_groupBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(627)
			p.valueExpression(0)
		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(628)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(629)
				p.valueExpression(0)
			}

			p.SetState(634)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(635)
			p.Match(KSqlParserT__2)
		}
		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72339056129740552) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&29026033097256961) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&4389507047193) != 0) {
			{
				p.SetState(636)
				p.valueExpression(0)
			}
			p.SetState(641)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(637)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(638)
					p.valueExpression(0)
				}

				p.SetState(643)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(646)
			p.Match(KSqlParserT__3)
		}

	}

	return localctx
}

// IPartitionByContext is an interface to support dynamic dispatch.
type IPartitionByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext

	// IsPartitionByContext differentiates from other interfaces.
	IsPartitionByContext()
}

type PartitionByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByContext() *PartitionByContext {
	var p = new(PartitionByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_partitionBy
	return p
}

func (*PartitionByContext) IsPartitionByContext() {}

func NewPartitionByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByContext {
	var p = new(PartitionByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_partitionBy

	return p
}

func (s *PartitionByContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionByContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PartitionByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPartitionBy(s)
	}
}

func (s *PartitionByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPartitionBy(s)
	}
}

func (p *KSqlParser) PartitionBy() (localctx IPartitionByContext) {
	this := p
	_ = this

	localctx = NewPartitionByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KSqlParserRULE_partitionBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(649)
			p.valueExpression(0)
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(650)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(651)
				p.valueExpression(0)
			}

			p.SetState(656)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(657)
			p.Match(KSqlParserT__2)
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72339056129740552) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&29026033097256961) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&4389507047193) != 0) {
			{
				p.SetState(658)
				p.valueExpression(0)
			}
			p.SetState(663)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(659)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(660)
					p.valueExpression(0)
				}

				p.SetState(665)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(668)
			p.Match(KSqlParserT__3)
		}

	}

	return localctx
}

// IValuesContext is an interface to support dynamic dispatch.
type IValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext

	// IsValuesContext differentiates from other interfaces.
	IsValuesContext()
}

type ValuesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesContext() *ValuesContext {
	var p = new(ValuesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_values
	return p
}

func (*ValuesContext) IsValuesContext() {}

func NewValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesContext {
	var p = new(ValuesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_values

	return p
}

func (s *ValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ValuesContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterValues(s)
	}
}

func (s *ValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitValues(s)
	}
}

func (p *KSqlParser) Values() (localctx IValuesContext) {
	this := p
	_ = this

	localctx = NewValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KSqlParserRULE_values)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(KSqlParserT__2)
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72339056129740552) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&29026033097256961) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&4389507047193) != 0) {
		{
			p.SetState(672)
			p.valueExpression(0)
		}
		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(673)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(674)
				p.valueExpression(0)
			}

			p.SetState(679)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(682)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_selectItem
	return p
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyFrom(ctx *SelectItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	*SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

type SelectSingleContext struct {
	*SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (p *KSqlParser) SelectItem() (localctx ISelectItemContext) {
	this := p
	_ = this

	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KSqlParserRULE_selectItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(684)
			p.Expression()
		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72338935870672640) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&-1040324427489247229) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&1040187425) != 0) {
			p.SetState(686)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == KSqlParserAS {
				{
					p.SetState(685)
					p.Match(KSqlParserAS)
				}

			}
			{
				p.SetState(688)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(691)
			p.Identifier()
		}
		{
			p.SetState(692)
			p.Match(KSqlParserT__4)
		}
		{
			p.SetState(693)
			p.Match(KSqlParserASTERISK)
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(695)
			p.Match(KSqlParserASTERISK)
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyFrom(ctx *RelationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	*RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) AliasedRelation() IAliasedRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

type JoinRelationContext struct {
	*RelationContext
	left IAliasedRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IAliasedRelationContext { return s.left }

func (s *JoinRelationContext) SetLeft(v IAliasedRelationContext) { s.left = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AliasedRelation() IAliasedRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *JoinRelationContext) AllJoinedSource() []IJoinedSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinedSourceContext); ok {
			len++
		}
	}

	tst := make([]IJoinedSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinedSourceContext); ok {
			tst[i] = t.(IJoinedSourceContext)
			i++
		}
	}

	return tst
}

func (s *JoinRelationContext) JoinedSource(i int) IJoinedSourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinedSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinedSourceContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *KSqlParser) Relation() (localctx IRelationContext) {
	this := p
	_ = this

	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KSqlParserRULE_relation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)

			var _x = p.AliasedRelation()

			localctx.(*JoinRelationContext).left = _x
		}
		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&27) != 0) {
			{
				p.SetState(699)
				p.JoinedSource()
			}

			p.SetState(702)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewRelationDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(704)
			p.AliasedRelation()
		}

	}

	return localctx
}

// IJoinedSourceContext is an interface to support dynamic dispatch.
type IJoinedSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JoinType() IJoinTypeContext
	JOIN() antlr.TerminalNode
	AliasedRelation() IAliasedRelationContext
	JoinCriteria() IJoinCriteriaContext
	JoinWindow() IJoinWindowContext

	// IsJoinedSourceContext differentiates from other interfaces.
	IsJoinedSourceContext()
}

type JoinedSourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinedSourceContext() *JoinedSourceContext {
	var p = new(JoinedSourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinedSource
	return p
}

func (*JoinedSourceContext) IsJoinedSourceContext() {}

func NewJoinedSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinedSourceContext {
	var p = new(JoinedSourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinedSource

	return p
}

func (s *JoinedSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinedSourceContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinedSourceContext) JOIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserJOIN, 0)
}

func (s *JoinedSourceContext) AliasedRelation() IAliasedRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *JoinedSourceContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinedSourceContext) JoinWindow() IJoinWindowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinWindowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinWindowContext)
}

func (s *JoinedSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinedSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinedSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinedSource(s)
	}
}

func (s *JoinedSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinedSource(s)
	}
}

func (p *KSqlParser) JoinedSource() (localctx IJoinedSourceContext) {
	this := p
	_ = this

	localctx = NewJoinedSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KSqlParserRULE_joinedSource)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(707)
		p.JoinType()
	}
	{
		p.SetState(708)
		p.Match(KSqlParserJOIN)
	}
	{
		p.SetState(709)
		p.AliasedRelation()
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWITHIN {
		{
			p.SetState(710)
			p.JoinWindow()
		}

	}
	{
		p.SetState(713)
		p.JoinCriteria()
	}

	return localctx
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinType
	return p
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) CopyFrom(ctx *JoinTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InnerJoinContext struct {
	*JoinTypeContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(KSqlParserINNER, 0)
}

func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

type LeftJoinContext struct {
	*JoinTypeContext
}

func NewLeftJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LeftJoinContext {
	var p = new(LeftJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *LeftJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLEFT, 0)
}

func (s *LeftJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserOUTER, 0)
}

func (s *LeftJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLeftJoin(s)
	}
}

func (s *LeftJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLeftJoin(s)
	}
}

type OuterJoinContext struct {
	*JoinTypeContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) FULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFULL, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserOUTER, 0)
}

func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

func (p *KSqlParser) JoinType() (localctx IJoinTypeContext) {
	this := p
	_ = this

	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KSqlParserRULE_joinType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(726)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserJOIN, KSqlParserINNER:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserINNER {
			{
				p.SetState(715)
				p.Match(KSqlParserINNER)
			}

		}

	case KSqlParserFULL:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(718)
			p.Match(KSqlParserFULL)
		}
		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOUTER {
			{
				p.SetState(719)
				p.Match(KSqlParserOUTER)
			}

		}

	case KSqlParserLEFT:
		localctx = NewLeftJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(722)
			p.Match(KSqlParserLEFT)
		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOUTER {
			{
				p.SetState(723)
				p.Match(KSqlParserOUTER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinWindowContext is an interface to support dynamic dispatch.
type IJoinWindowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITHIN() antlr.TerminalNode
	WithinExpression() IWithinExpressionContext

	// IsJoinWindowContext differentiates from other interfaces.
	IsJoinWindowContext()
}

type JoinWindowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinWindowContext() *JoinWindowContext {
	var p = new(JoinWindowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinWindow
	return p
}

func (*JoinWindowContext) IsJoinWindowContext() {}

func NewJoinWindowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinWindowContext {
	var p = new(JoinWindowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinWindow

	return p
}

func (s *JoinWindowContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinWindowContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITHIN, 0)
}

func (s *JoinWindowContext) WithinExpression() IWithinExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithinExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithinExpressionContext)
}

func (s *JoinWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindow(s)
	}
}

func (s *JoinWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindow(s)
	}
}

func (p *KSqlParser) JoinWindow() (localctx IJoinWindowContext) {
	this := p
	_ = this

	localctx = NewJoinWindowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KSqlParserRULE_joinWindow)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(KSqlParserWITHIN)
	}
	{
		p.SetState(729)
		p.WithinExpression()
	}

	return localctx
}

// IWithinExpressionContext is an interface to support dynamic dispatch.
type IWithinExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWithinExpressionContext differentiates from other interfaces.
	IsWithinExpressionContext()
}

type WithinExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithinExpressionContext() *WithinExpressionContext {
	var p = new(WithinExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_withinExpression
	return p
}

func (*WithinExpressionContext) IsWithinExpressionContext() {}

func NewWithinExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithinExpressionContext {
	var p = new(WithinExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_withinExpression

	return p
}

func (s *WithinExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithinExpressionContext) CopyFrom(ctx *WithinExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *WithinExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithinExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SingleJoinWindowContext struct {
	*WithinExpressionContext
}

func NewSingleJoinWindowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleJoinWindowContext {
	var p = new(SingleJoinWindowContext)

	p.WithinExpressionContext = NewEmptyWithinExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WithinExpressionContext))

	return p
}

func (s *SingleJoinWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleJoinWindowContext) JoinWindowSize() IJoinWindowSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinWindowSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinWindowSizeContext)
}

func (s *SingleJoinWindowContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *SingleJoinWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleJoinWindow(s)
	}
}

func (s *SingleJoinWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleJoinWindow(s)
	}
}

type JoinWindowWithBeforeAndAfterContext struct {
	*WithinExpressionContext
}

func NewJoinWindowWithBeforeAndAfterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinWindowWithBeforeAndAfterContext {
	var p = new(JoinWindowWithBeforeAndAfterContext)

	p.WithinExpressionContext = NewEmptyWithinExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WithinExpressionContext))

	return p
}

func (s *JoinWindowWithBeforeAndAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowWithBeforeAndAfterContext) AllJoinWindowSize() []IJoinWindowSizeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinWindowSizeContext); ok {
			len++
		}
	}

	tst := make([]IJoinWindowSizeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinWindowSizeContext); ok {
			tst[i] = t.(IJoinWindowSizeContext)
			i++
		}
	}

	return tst
}

func (s *JoinWindowWithBeforeAndAfterContext) JoinWindowSize(i int) IJoinWindowSizeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinWindowSizeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinWindowSizeContext)
}

func (s *JoinWindowWithBeforeAndAfterContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *JoinWindowWithBeforeAndAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindowWithBeforeAndAfter(s)
	}
}

func (s *JoinWindowWithBeforeAndAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindowWithBeforeAndAfter(s)
	}
}

func (p *KSqlParser) WithinExpression() (localctx IWithinExpressionContext) {
	this := p
	_ = this

	localctx = NewWithinExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KSqlParserRULE_withinExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(743)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__2:
		localctx = NewJoinWindowWithBeforeAndAfterContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(731)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(732)
			p.JoinWindowSize()
		}
		{
			p.SetState(733)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(734)
			p.JoinWindowSize()
		}
		{
			p.SetState(735)
			p.Match(KSqlParserT__3)
		}
		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserGRACE {
			{
				p.SetState(736)
				p.GracePeriodClause()
			}

		}

	case KSqlParserMINUS, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE:
		localctx = NewSingleJoinWindowContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.JoinWindowSize()
		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserGRACE {
			{
				p.SetState(740)
				p.GracePeriodClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinWindowSizeContext is an interface to support dynamic dispatch.
type IJoinWindowSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	WindowUnit() IWindowUnitContext

	// IsJoinWindowSizeContext differentiates from other interfaces.
	IsJoinWindowSizeContext()
}

type JoinWindowSizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinWindowSizeContext() *JoinWindowSizeContext {
	var p = new(JoinWindowSizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinWindowSize
	return p
}

func (*JoinWindowSizeContext) IsJoinWindowSizeContext() {}

func NewJoinWindowSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinWindowSizeContext {
	var p = new(JoinWindowSizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinWindowSize

	return p
}

func (s *JoinWindowSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinWindowSizeContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *JoinWindowSizeContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *JoinWindowSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinWindowSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindowSize(s)
	}
}

func (s *JoinWindowSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindowSize(s)
	}
}

func (p *KSqlParser) JoinWindowSize() (localctx IJoinWindowSizeContext) {
	this := p
	_ = this

	localctx = NewJoinWindowSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KSqlParserRULE_joinWindowSize)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Number()
	}
	{
		p.SetState(746)
		p.WindowUnit()
	}

	return localctx
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinCriteria
	return p
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(KSqlParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *KSqlParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	this := p
	_ = this

	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KSqlParserRULE_joinCriteria)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.Match(KSqlParserON)
	}
	{
		p.SetState(749)
		p.booleanExpression(0)
	}

	return localctx
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	SourceName() ISourceNameContext
	AS() antlr.TerminalNode

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_aliasedRelation
	return p
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (p *KSqlParser) AliasedRelation() (localctx IAliasedRelationContext) {
	this := p
	_ = this

	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KSqlParserRULE_aliasedRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(751)
		p.RelationPrimary()
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserAS {
			{
				p.SetState(752)
				p.Match(KSqlParserAS)
			}

		}
		{
			p.SetState(755)
			p.SourceName()
		}

	}

	return localctx
}

// IColumnsContext is an interface to support dynamic dispatch.
type IColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnsContext differentiates from other interfaces.
	IsColumnsContext()
}

type ColumnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsContext() *ColumnsContext {
	var p = new(ColumnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_columns
	return p
}

func (*ColumnsContext) IsColumnsContext() {}

func NewColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsContext {
	var p = new(ColumnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_columns

	return p
}

func (s *ColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnsContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterColumns(s)
	}
}

func (s *ColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitColumns(s)
	}
}

func (p *KSqlParser) Columns() (localctx IColumnsContext) {
	this := p
	_ = this

	localctx = NewColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KSqlParserRULE_columns)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(759)
		p.Identifier()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(760)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(761)
			p.Identifier()
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(767)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_relationPrimary
	return p
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyFrom(ctx *RelationPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableNameContext struct {
	*RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *KSqlParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	this := p
	_ = this

	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KSqlParserRULE_relationPrimary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewTableNameContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.SourceName()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *KSqlParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KSqlParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.booleanExpression(0)
	}

	return localctx
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_booleanExpression
	return p
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyFrom(ctx *BooleanExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	*BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type BooleanDefaultContext struct {
	*BooleanExpressionContext
}

func NewBooleanDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanDefaultContext {
	var p = new(BooleanDefaultContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanDefaultContext) Predicated() IPredicatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicatedContext)
}

func (s *BooleanDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanDefault(s)
	}
}

func (s *BooleanDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanDefault(s)
	}
}

type LogicalBinaryContext struct {
	*BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(KSqlParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *KSqlParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *KSqlParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 80
	p.EnterRecursionRule(localctx, 80, KSqlParserRULE_booleanExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(777)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__2, KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserNULL, KSqlParserTRUE, KSqlParserFALSE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserCASE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserCAST, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserPLUS, KSqlParserMINUS, KSqlParserSTRING, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		localctx = NewBooleanDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(774)
			p.Predicated()
		}

	case KSqlParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(775)
			p.Match(KSqlParserNOT)
		}
		{
			p.SetState(776)
			p.booleanExpression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(785)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_booleanExpression)
				p.SetState(779)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(780)

					var _m = p.Match(KSqlParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(781)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_booleanExpression)
				p.SetState(782)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(783)

					var _m = p.Match(KSqlParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(784)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			}

		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicatedContext is an interface to support dynamic dispatch.
type IPredicatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// Getter signatures
	ValueExpression() IValueExpressionContext
	Predicate() IPredicateContext

	// IsPredicatedContext differentiates from other interfaces.
	IsPredicatedContext()
}

type PredicatedContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicatedContext() *PredicatedContext {
	var p = new(PredicatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_predicated
	return p
}

func (*PredicatedContext) IsPredicatedContext() {}

func NewPredicatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicatedContext {
	var p = new(PredicatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_predicated

	return p
}

func (s *PredicatedContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicatedContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicatedContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPredicated(s)
	}
}

func (p *KSqlParser) Predicated() (localctx IPredicatedContext) {
	this := p
	_ = this

	localctx = NewPredicatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KSqlParserRULE_predicated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)

		var _x = p.valueExpression(0)

		localctx.(*PredicatedContext)._valueExpression = _x
	}
	p.SetState(792)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(791)
			p.Predicate(localctx.(*PredicatedContext).Get_valueExpression())
		}

	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() antlr.ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(antlr.ParserRuleContext)

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.ParserRuleContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value antlr.ParserRuleContext) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_predicate

	p.value = value

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetValue() antlr.ParserRuleContext { return s.value }

func (s *PredicateContext) SetValue(v antlr.ParserRuleContext) { s.value = v }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitComparison(s)
	}
}

type LikeContext struct {
	*PredicateContext
	pattern IValueExpressionContext
	escape  antlr.Token
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetEscape() antlr.Token { return s.escape }

func (s *LikeContext) SetEscape(v antlr.Token) { s.escape = v }

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIKE, 0)
}

func (s *LikeContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserESCAPE, 0)
}

func (s *LikeContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLike(s)
	}
}

type DistinctFromContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(KSqlParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

type InListContext struct {
	*PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(KSqlParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInList(s)
	}
}

type NullPredicateContext struct {
	*PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(KSqlParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

type BetweenContext struct {
	*PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(KSqlParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (p *KSqlParser) Predicate(value antlr.ParserRuleContext) (localctx IPredicateContext) {
	this := p
	_ = this

	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 84, KSqlParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(794)
			p.ComparisonOperator()
		}
		{
			p.SetState(795)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(797)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(800)
			p.Match(KSqlParserBETWEEN)
		}
		{
			p.SetState(801)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(802)
			p.Match(KSqlParserAND)
		}
		{
			p.SetState(803)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 3:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(805)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(808)
			p.Match(KSqlParserIN)
		}
		{
			p.SetState(809)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(810)
			p.Expression()
		}
		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(811)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(812)
				p.Expression()
			}

			p.SetState(817)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(818)
			p.Match(KSqlParserT__3)
		}

	case 4:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(820)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(823)
			p.Match(KSqlParserLIKE)
		}
		{
			p.SetState(824)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(825)
				p.Match(KSqlParserESCAPE)
			}
			{
				p.SetState(826)

				var _m = p.Match(KSqlParserSTRING)

				localctx.(*LikeContext).escape = _m
			}

		}

	case 5:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(829)
			p.Match(KSqlParserIS)
		}
		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(830)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(833)
			p.Match(KSqlParserNULL)
		}

	case 6:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(834)
			p.Match(KSqlParserIS)
		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(835)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(838)
			p.Match(KSqlParserDISTINCT)
		}
		{
			p.SetState(839)
			p.Match(KSqlParserFROM)
		}
		{
			p.SetState(840)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	}

	return localctx
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_valueExpression
	return p
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyFrom(ctx *ValueExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	*ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ConcatenationContext struct {
	*ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

type ArithmeticBinaryContext struct {
	*ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(KSqlParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(KSqlParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	*ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

type AtTimeZoneContext struct {
	*ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(KSqlParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeZoneSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (p *KSqlParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *KSqlParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, KSqlParserRULE_valueExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(844)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(845)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserPLUS || _la == KSqlParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(846)
			p.valueExpression(4)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(861)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(849)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(850)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-154)) & ^0x3f) == 0 && ((int64(1)<<(_la-154))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(851)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(852)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(853)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == KSqlParserPLUS || _la == KSqlParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(854)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(855)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(856)
					p.Match(KSqlParserCONCAT)
				}
				{
					p.SetState(857)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(858)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(859)
					p.Match(KSqlParserAT)
				}
				{
					p.SetState(860)
					p.TimeZoneSpecifier()
				}

			}

		}
		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyFrom(ctx *PrimaryExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	*PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) STRUCT_FIELD_REF() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT_FIELD_REF, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDereference(s)
	}
}

type SimpleCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(KSqlParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type SubscriptContext struct {
	*PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type StructConstructorContext struct {
	*PrimaryExpressionContext
}

func NewStructConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructConstructorContext {
	var p = new(StructConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StructConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructConstructorContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *StructConstructorContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *StructConstructorContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructConstructorContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserASSIGN)
}

func (s *StructConstructorContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserASSIGN, i)
}

func (s *StructConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StructConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StructConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStructConstructor(s)
	}
}

func (s *StructConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStructConstructor(s)
	}
}

type TypeConstructorContext struct {
	*PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type QualifiedColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewQualifiedColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedColumnReferenceContext {
	var p = new(QualifiedColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *QualifiedColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedColumnReferenceContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedColumnReferenceContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQualifiedColumnReference(s)
	}
}

func (s *QualifiedColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQualifiedColumnReference(s)
	}
}

type CastContext struct {
	*PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(KSqlParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CastContext) Sqltype() ISqltypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqltypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCast(s)
	}
}

type ParenthesizedExpressionContext struct {
	*PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type ArrayConstructorContext struct {
	*PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

type MapConstructorContext struct {
	*PrimaryExpressionContext
}

func NewMapConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapConstructorContext {
	var p = new(MapConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *MapConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapConstructorContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserASSIGN)
}

func (s *MapConstructorContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserASSIGN, i)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

type FunctionCallContext struct {
	*PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *FunctionCallContext) AllFunctionArgument() []IFunctionArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgumentContext); ok {
			tst[i] = t.(IFunctionArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) FunctionArgument(i int) IFunctionArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *FunctionCallContext) AllLambdaFunction() []ILambdaFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaFunctionContext); ok {
			len++
		}
	}

	tst := make([]ILambdaFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaFunctionContext); ok {
			tst[i] = t.(ILambdaFunctionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) LambdaFunction(i int) ILambdaFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type SearchedCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(KSqlParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type LiteralExpressionContext struct {
	*PrimaryExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (p *KSqlParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *KSqlParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 88
	p.EnterRecursionRule(localctx, 88, KSqlParserRULE_primaryExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(867)
			p.Literal()
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(868)
			p.Identifier()
		}
		{
			p.SetState(869)
			p.Match(KSqlParserSTRING)
		}

	case 3:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(871)
			p.Match(KSqlParserCASE)
		}
		{
			p.SetState(872)
			p.valueExpression(0)
		}
		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KSqlParserWHEN {
			{
				p.SetState(873)
				p.WhenClause()
			}

			p.SetState(876)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserELSE {
			{
				p.SetState(878)
				p.Match(KSqlParserELSE)
			}
			{
				p.SetState(879)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(882)
			p.Match(KSqlParserEND)
		}

	case 4:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(884)
			p.Match(KSqlParserCASE)
		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KSqlParserWHEN {
			{
				p.SetState(885)
				p.WhenClause()
			}

			p.SetState(888)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(892)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserELSE {
			{
				p.SetState(890)
				p.Match(KSqlParserELSE)
			}
			{
				p.SetState(891)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(894)
			p.Match(KSqlParserEND)
		}

	case 5:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(896)
			p.Match(KSqlParserCAST)
		}
		{
			p.SetState(897)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(898)
			p.Expression()
		}
		{
			p.SetState(899)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(900)
			p.sqltype(0)
		}
		{
			p.SetState(901)
			p.Match(KSqlParserT__3)
		}

	case 6:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(903)
			p.Match(KSqlParserARRAY)
		}
		{
			p.SetState(904)
			p.Match(KSqlParserT__5)
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72339056398176008) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&29026033097256961) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&4389507047193) != 0) {
			{
				p.SetState(905)
				p.Expression()
			}
			p.SetState(910)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(906)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(907)
					p.Expression()
				}

				p.SetState(912)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(915)
			p.Match(KSqlParserT__6)
		}

	case 7:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(916)
			p.Match(KSqlParserMAP)
		}
		{
			p.SetState(917)
			p.Match(KSqlParserT__2)
		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72339056398176008) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&29026033097256961) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&4389507047193) != 0) {
			{
				p.SetState(918)
				p.Expression()
			}
			{
				p.SetState(919)
				p.Match(KSqlParserASSIGN)
			}
			{
				p.SetState(920)
				p.Expression()
			}
			p.SetState(928)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(921)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(922)
					p.Expression()
				}
				{
					p.SetState(923)
					p.Match(KSqlParserASSIGN)
				}
				{
					p.SetState(924)
					p.Expression()
				}

				p.SetState(930)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(933)
			p.Match(KSqlParserT__3)
		}

	case 8:
		localctx = NewStructConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(934)
			p.Match(KSqlParserSTRUCT)
		}
		{
			p.SetState(935)
			p.Match(KSqlParserT__2)
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72338935870656256) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&-1040324427489247229) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&1040187425) != 0) {
			{
				p.SetState(936)
				p.Identifier()
			}
			{
				p.SetState(937)
				p.Match(KSqlParserASSIGN)
			}
			{
				p.SetState(938)
				p.Expression()
			}
			p.SetState(946)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(939)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(940)
					p.Identifier()
				}
				{
					p.SetState(941)
					p.Match(KSqlParserASSIGN)
				}
				{
					p.SetState(942)
					p.Expression()
				}

				p.SetState(948)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(951)
			p.Match(KSqlParserT__3)
		}

	case 9:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(952)
			p.Identifier()
		}
		{
			p.SetState(953)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(954)
			p.Match(KSqlParserASTERISK)
		}
		{
			p.SetState(955)
			p.Match(KSqlParserT__3)
		}

	case 10:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(957)
			p.Identifier()
		}
		{
			p.SetState(958)
			p.Match(KSqlParserT__2)
		}
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&142426325599129352) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&29026033097256961) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&4389507047193) != 0) {
			{
				p.SetState(959)
				p.FunctionArgument()
			}
			p.SetState(964)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(960)
						p.Match(KSqlParserT__1)
					}
					{
						p.SetState(961)
						p.FunctionArgument()
					}

				}
				p.SetState(966)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
			}
			p.SetState(971)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(967)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(968)
					p.LambdaFunction()
				}

				p.SetState(973)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(976)
			p.Match(KSqlParserT__3)
		}

	case 11:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(978)
			p.Identifier()
		}

	case 12:
		localctx = NewQualifiedColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(979)
			p.Identifier()
		}
		{
			p.SetState(980)
			p.Match(KSqlParserT__4)
		}
		{
			p.SetState(981)
			p.Identifier()
		}

	case 13:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(983)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(984)
			p.Expression()
		}
		{
			p.SetState(985)
			p.Match(KSqlParserT__3)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(997)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_primaryExpression)
				p.SetState(989)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(990)
					p.Match(KSqlParserT__5)
				}
				{
					p.SetState(991)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(992)
					p.Match(KSqlParserT__6)
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_primaryExpression)
				p.SetState(994)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(995)
					p.Match(KSqlParserSTRUCT_FIELD_REF)
				}
				{
					p.SetState(996)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			}

		}
		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}

	return localctx
}

// IFunctionArgumentContext is an interface to support dynamic dispatch.
type IFunctionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	WindowUnit() IWindowUnitContext

	// IsFunctionArgumentContext differentiates from other interfaces.
	IsFunctionArgumentContext()
}

type FunctionArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentContext() *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_functionArgument
	return p
}

func (*FunctionArgumentContext) IsFunctionArgumentContext() {}

func NewFunctionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_functionArgument

	return p
}

func (s *FunctionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgumentContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *FunctionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFunctionArgument(s)
	}
}

func (s *FunctionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFunctionArgument(s)
	}
}

func (p *KSqlParser) FunctionArgument() (localctx IFunctionArgumentContext) {
	this := p
	_ = this

	localctx = NewFunctionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KSqlParserRULE_functionArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1002)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1003)
			p.WindowUnit()
		}

	}

	return localctx
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_timeZoneSpecifier
	return p
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyFrom(ctx *TimeZoneSpecifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneStringContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(KSqlParserZONE, 0)
}

func (s *TimeZoneStringContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (p *KSqlParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	this := p
	_ = this

	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KSqlParserRULE_timeZoneSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewTimeZoneStringContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(KSqlParserTIME)
	}
	{
		p.SetState(1007)
		p.Match(KSqlParserZONE)
	}
	{
		p.SetState(1008)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(KSqlParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *KSqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KSqlParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1010)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-146)) & ^0x3f) == 0 && ((int64(1)<<(_la-146))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *KSqlParser) BooleanValue() (localctx IBooleanValueContext) {
	this := p
	_ = this

	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KSqlParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserTRUE || _la == KSqlParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISqltypeContext is an interface to support dynamic dispatch.
type ISqltypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllSqltype() []ISqltypeContext
	Sqltype(i int) ISqltypeContext
	GT() antlr.TerminalNode
	MAP() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	DECIMAL() antlr.TerminalNode
	AllNumber() []INumberContext
	Number(i int) INumberContext
	BaseType() IBaseTypeContext
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext

	// IsSqltypeContext differentiates from other interfaces.
	IsSqltypeContext()
}

type SqltypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqltypeContext() *SqltypeContext {
	var p = new(SqltypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sqltype
	return p
}

func (*SqltypeContext) IsSqltypeContext() {}

func NewSqltypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqltypeContext {
	var p = new(SqltypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sqltype

	return p
}

func (s *SqltypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SqltypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *SqltypeContext) LT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLT, 0)
}

func (s *SqltypeContext) AllSqltype() []ISqltypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqltypeContext); ok {
			len++
		}
	}

	tst := make([]ISqltypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqltypeContext); ok {
			tst[i] = t.(ISqltypeContext)
			i++
		}
	}

	return tst
}

func (s *SqltypeContext) Sqltype(i int) ISqltypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqltypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *SqltypeContext) GT() antlr.TerminalNode {
	return s.GetToken(KSqlParserGT, 0)
}

func (s *SqltypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *SqltypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *SqltypeContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *SqltypeContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SqltypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserDECIMAL, 0)
}

func (s *SqltypeContext) AllNumber() []INumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberContext); ok {
			len++
		}
	}

	tst := make([]INumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberContext); ok {
			tst[i] = t.(INumberContext)
			i++
		}
	}

	return tst
}

func (s *SqltypeContext) Number(i int) INumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SqltypeContext) BaseType() IBaseTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *SqltypeContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *SqltypeContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *SqltypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqltypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqltypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSqltype(s)
	}
}

func (s *SqltypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSqltype(s)
	}
}

func (p *KSqlParser) Sqltype() (localctx ISqltypeContext) {
	return p.sqltype(0)
}

func (p *KSqlParser) sqltype(_p int) (localctx ISqltypeContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSqltypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISqltypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 98
	p.EnterRecursionRule(localctx, 98, KSqlParserRULE_sqltype, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1015)
			p.Match(KSqlParserARRAY)
		}
		{
			p.SetState(1016)
			p.Match(KSqlParserLT)
		}
		{
			p.SetState(1017)
			p.sqltype(0)
		}
		{
			p.SetState(1018)
			p.Match(KSqlParserGT)
		}

	case 2:
		{
			p.SetState(1020)
			p.Match(KSqlParserMAP)
		}
		{
			p.SetState(1021)
			p.Match(KSqlParserLT)
		}
		{
			p.SetState(1022)
			p.sqltype(0)
		}
		{
			p.SetState(1023)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(1024)
			p.sqltype(0)
		}
		{
			p.SetState(1025)
			p.Match(KSqlParserGT)
		}

	case 3:
		{
			p.SetState(1027)
			p.Match(KSqlParserSTRUCT)
		}
		{
			p.SetState(1028)
			p.Match(KSqlParserLT)
		}
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72338935870656256) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&-1040324427489247229) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&1040187425) != 0) {
			{
				p.SetState(1029)
				p.Identifier()
			}
			{
				p.SetState(1030)
				p.sqltype(0)
			}
			p.SetState(1037)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(1031)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(1032)
					p.Identifier()
				}
				{
					p.SetState(1033)
					p.sqltype(0)
				}

				p.SetState(1039)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1042)
			p.Match(KSqlParserGT)
		}

	case 4:
		{
			p.SetState(1043)
			p.Match(KSqlParserDECIMAL)
		}
		{
			p.SetState(1044)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(1045)
			p.Number()
		}
		{
			p.SetState(1046)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(1047)
			p.Number()
		}
		{
			p.SetState(1048)
			p.Match(KSqlParserT__3)
		}

	case 5:
		{
			p.SetState(1050)
			p.BaseType()
		}
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1051)
				p.Match(KSqlParserT__2)
			}
			{
				p.SetState(1052)
				p.TypeParameter()
			}
			p.SetState(1057)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(1053)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(1054)
					p.TypeParameter()
				}

				p.SetState(1059)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1060)
				p.Match(KSqlParserT__3)
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSqltypeContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_sqltype)
			p.SetState(1066)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
			}
			{
				p.SetState(1067)
				p.Match(KSqlParserARRAY)
			}

		}
		p.SetState(1072)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *KSqlParser) TypeParameter() (localctx ITypeParameterContext) {
	this := p
	_ = this

	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KSqlParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserT__7 || _la == KSqlParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_baseType
	return p
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *KSqlParser) BaseType() (localctx IBaseTypeContext) {
	this := p
	_ = this

	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KSqlParserRULE_baseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Identifier()
	}

	return localctx
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_whenClause
	return p
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *KSqlParser) WhenClause() (localctx IWhenClauseContext) {
	this := p
	_ = this

	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KSqlParserRULE_whenClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		p.Match(KSqlParserWHEN)
	}
	{
		p.SetState(1078)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1079)
		p.Match(KSqlParserTHEN)
	}
	{
		p.SetState(1080)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyFrom(ctx *IdentifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type VariableIdentifierContext struct {
	*IdentifierContext
}

func NewVariableIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableIdentifierContext {
	var p = new(VariableIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *VariableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableIdentifierContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLE, 0)
}

func (s *VariableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableIdentifier(s)
	}
}

func (s *VariableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableIdentifier(s)
	}
}

type BackQuotedIdentifierContext struct {
	*IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

type QuotedIdentifierAlternativeContext struct {
	*IdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type DigitIdentifierContext struct {
	*IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

type UnquotedIdentifierContext struct {
	*IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *KSqlParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KSqlParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1088)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserVARIABLE:
		localctx = NewVariableIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1082)
			p.Match(KSqlParserVARIABLE)
		}

	case KSqlParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1083)
			p.Match(KSqlParserIDENTIFIER)
		}

	case KSqlParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1084)
			p.Match(KSqlParserQUOTED_IDENTIFIER)
		}

	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1085)
			p.NonReserved()
		}

	case KSqlParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1086)
			p.Match(KSqlParserBACKQUOTED_IDENTIFIER)
		}

	case KSqlParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1087)
			p.Match(KSqlParserDIGIT_IDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILambdaFunctionContext is an interface to support dynamic dispatch.
type ILambdaFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLambdaFunctionContext differentiates from other interfaces.
	IsLambdaFunctionContext()
}

type LambdaFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionContext() *LambdaFunctionContext {
	var p = new(LambdaFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_lambdaFunction
	return p
}

func (*LambdaFunctionContext) IsLambdaFunctionContext() {}

func NewLambdaFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionContext {
	var p = new(LambdaFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_lambdaFunction

	return p
}

func (s *LambdaFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionContext) CopyFrom(ctx *LambdaFunctionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LambdaFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LambdaContext struct {
	*LambdaFunctionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	p.LambdaFunctionContext = NewEmptyLambdaFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LambdaFunctionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) LAMBDA_EXPRESSION() antlr.TerminalNode {
	return s.GetToken(KSqlParserLAMBDA_EXPRESSION, 0)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (p *KSqlParser) LambdaFunction() (localctx ILambdaFunctionContext) {
	this := p
	_ = this

	localctx = NewLambdaFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KSqlParserRULE_lambdaFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1107)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		localctx = NewLambdaContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1090)
			p.Identifier()
		}
		{
			p.SetState(1091)
			p.Match(KSqlParserLAMBDA_EXPRESSION)
		}
		{
			p.SetState(1092)
			p.Expression()
		}

	case KSqlParserT__2:
		localctx = NewLambdaContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1094)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(1095)
			p.Identifier()
		}
		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(1096)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(1097)
				p.Identifier()
			}

			p.SetState(1102)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1103)
			p.Match(KSqlParserT__3)
		}
		{
			p.SetState(1104)
			p.Match(KSqlParserLAMBDA_EXPRESSION)
		}
		{
			p.SetState(1105)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableNameContext is an interface to support dynamic dispatch.
type IVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsVariableNameContext differentiates from other interfaces.
	IsVariableNameContext()
}

type VariableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameContext() *VariableNameContext {
	var p = new(VariableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_variableName
	return p
}

func (*VariableNameContext) IsVariableNameContext() {}

func NewVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameContext {
	var p = new(VariableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_variableName

	return p
}

func (s *VariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *VariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableName(s)
	}
}

func (s *VariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableName(s)
	}
}

func (p *KSqlParser) VariableName() (localctx IVariableNameContext) {
	this := p
	_ = this

	localctx = NewVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, KSqlParserRULE_variableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Match(KSqlParserIDENTIFIER)
	}

	return localctx
}

// IVariableValueContext is an interface to support dynamic dispatch.
type IVariableValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsVariableValueContext differentiates from other interfaces.
	IsVariableValueContext()
}

type VariableValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableValueContext() *VariableValueContext {
	var p = new(VariableValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_variableValue
	return p
}

func (*VariableValueContext) IsVariableValueContext() {}

func NewVariableValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableValueContext {
	var p = new(VariableValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_variableValue

	return p
}

func (s *VariableValueContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *VariableValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableValue(s)
	}
}

func (s *VariableValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableValue(s)
	}
}

func (p *KSqlParser) VariableValue() (localctx IVariableValueContext) {
	this := p
	_ = this

	localctx = NewVariableValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KSqlParserRULE_variableValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1111)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// ISourceNameContext is an interface to support dynamic dispatch.
type ISourceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsSourceNameContext differentiates from other interfaces.
	IsSourceNameContext()
}

type SourceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceNameContext() *SourceNameContext {
	var p = new(SourceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sourceName
	return p
}

func (*SourceNameContext) IsSourceNameContext() {}

func NewSourceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceNameContext {
	var p = new(SourceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sourceName

	return p
}

func (s *SourceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SourceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSourceName(s)
	}
}

func (s *SourceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSourceName(s)
	}
}

func (p *KSqlParser) SourceName() (localctx ISourceNameContext) {
	this := p
	_ = this

	localctx = NewSourceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KSqlParserRULE_sourceName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1113)
		p.Identifier()
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyFrom(ctx *NumberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	*NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type FloatLiteralContext struct {
	*NumberContext
}

func NewFloatLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) FLOATING_POINT_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserFLOATING_POINT_VALUE, 0)
}

func (s *FloatLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

type IntegerLiteralContext struct {
	*NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *KSqlParser) Number() (localctx INumberContext) {
	this := p
	_ = this

	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KSqlParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1115)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1118)
			p.Match(KSqlParserDECIMAL_VALUE)
		}

	case 2:
		localctx = NewFloatLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1119)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1122)
			p.Match(KSqlParserFLOATING_POINT_VALUE)
		}

	case 3:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1123)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1126)
			p.Match(KSqlParserINTEGER_VALUE)
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyFrom(ctx *LiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NullLiteralContext struct {
	*LiteralContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	*LiteralContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type VariableLiteralContext struct {
	*LiteralContext
}

func NewVariableLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableLiteralContext {
	var p = new(VariableLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *VariableLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableLiteralContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLE, 0)
}

func (s *VariableLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableLiteral(s)
	}
}

func (s *VariableLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableLiteral(s)
	}
}

type NumericLiteralContext struct {
	*LiteralContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	*LiteralContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *KSqlParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KSqlParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserNULL:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1129)
			p.Match(KSqlParserNULL)
		}

	case KSqlParserMINUS, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1130)
			p.Number()
		}

	case KSqlParserTRUE, KSqlParserFALSE:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1131)
			p.BooleanValue()
		}

	case KSqlParserSTRING:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1132)
			p.Match(KSqlParserSTRING)
		}

	case KSqlParserVARIABLE:
		localctx = NewVariableLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1133)
			p.Match(KSqlParserVARIABLE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	SET() antlr.TerminalNode
	RESET() antlr.TerminalNode
	IF() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SINK() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	EMIT() antlr.TerminalNode
	CHANGES() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	ASSERT() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ADD() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_nonReserved
	return p
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLES, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMNS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMN, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITIONS, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTIONS, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTION, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(KSqlParserSESSION, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITION, 0)
}

func (s *NonReservedContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDATE, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIMESTAMP, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTERVAL, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(KSqlParserZONE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(KSqlParserYEAR, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(KSqlParserMONTH, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAY, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOUR, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTE, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECOND, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXPLAIN, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserANALYZE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPES, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(KSqlParserSET, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(KSqlParserRESET, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *NonReservedContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *NonReservedContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *NonReservedContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRIMARY, 0)
}

func (s *NonReservedContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *NonReservedContext) EMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserEMIT, 0)
}

func (s *NonReservedContext) CHANGES() antlr.TerminalNode {
	return s.GetToken(KSqlParserCHANGES, 0)
}

func (s *NonReservedContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFINAL, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserESCAPE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *NonReservedContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *NonReservedContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserALTER, 0)
}

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(KSqlParserADD, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *KSqlParser) NonReserved() (localctx INonReservedContext) {
	this := p
	_ = this

	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, KSqlParserRULE_nonReserved)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72338935870656256) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&-1040324427489247229) != 0) || _la == KSqlParserALTER || _la == KSqlParserIF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *KSqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 40:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 43:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 44:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 49:
		var t *SqltypeContext = nil
		if localctx != nil {
			t = localctx.(*SqltypeContext)
		}
		return p.Sqltype_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *KSqlParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) Sqltype_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
